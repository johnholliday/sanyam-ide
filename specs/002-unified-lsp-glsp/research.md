# Technical Research: Unified LSP/GLSP Language Server

**Feature**: 002-unified-lsp-glsp
**Date**: 2026-01-16
**Status**: Complete

## Executive Summary

This research document addresses six technical topics critical to implementing a unified language server for Sanyam IDE that combines LSP, GLSP, and Model API in a single Node.js process. Each section provides a recommended approach, rationale, and alternatives considered.

---

## 1. Langium 4.x Module System

### Decision

Use Langium's **module-based dependency injection with layered composition**. The pattern involves:

1. **`generatedSharedModule`**: Auto-generated by `langium generate`, contains shared services for cross-language functionality (connection handling, AST reflection, service registry)
2. **`generatedModule`**: Auto-generated per-language, contains language-specific services (parser, lexer, grammar access)
3. **Custom modules**: Developer-provided overrides that layer on top of generated modules

The composition pattern:

```typescript
export function createLanguageServices(context: DefaultSharedModuleContext): {
    shared: LangiumSharedServices,
    myLanguage: MyLanguageServices
} {
    // 1. Create shared services from defaults + generated
    const shared = inject(
        createDefaultSharedModule(context),
        MyLanguageGeneratedSharedModule
    );

    // 2. Create language-specific services with layered modules
    const myLanguage = inject(
        createDefaultModule({ shared }),
        MyLanguageGeneratedModule,
        MyLanguageCustomModule  // Custom overrides last
    );

    // 3. Register with the shared service registry
    shared.ServiceRegistry.register(myLanguage);

    return { shared, myLanguage };
}
```

### Rationale

- **Lazy Evaluation with Caching**: The `inject()` function creates proxy objects that instantiate services on first access and cache them as singletons
- **Cycle Detection**: Langium detects cyclic dependencies at runtime and requires explicit lazy evaluation for cycles
- **Module Merging**: Later modules override earlier ones via deep merge, enabling clean override patterns
- **Type Safety**: Full TypeScript generics preserve type information through the DI container

### Alternatives Considered

| Alternative | Reason Rejected |
|-------------|-----------------|
| Inversify directly | Langium already provides a tailored DI system; adding Inversify for Langium services would create redundant DI layers |
| Manual service instantiation | Loses lazy evaluation, cycle detection, and type-safe composition |
| Single flat module | Cannot separate generated from custom code; makes upgrades difficult |

---

## 2. Langium Services Extension Pattern

### Decision

Extend Langium services using **interface-based override registration** with these patterns:

**Pattern A: Extending Default Implementations**
```typescript
export class CustomScopeProvider extends DefaultScopeProvider {
    override getScope(context: ReferenceInfo): Scope {
        return super.getScope(context);
    }
}

export const CustomModule: Module<MyServices, PartialLangiumServices> = {
    references: {
        ScopeProvider: (services) => new CustomScopeProvider(services)
    }
};
```

**Pattern B: Adding New Services**
```typescript
export type CustomAddedServices = {
    validation: {
        CustomValidator: CustomValidator
    }
};

export const CustomModule: Module<MyLanguageServices, CustomAddedServices> = {
    validation: {
        CustomValidator: () => new CustomValidator()
    }
};
```

### Key LSP Services to Override

| Service | Purpose | Override When |
|---------|---------|---------------|
| `CompletionProvider` | Code completion suggestions | Custom completion logic needed |
| `HoverProvider` | Tooltip content | Rich hover documentation |
| `DocumentSymbolProvider` | Outline view symbols | Custom symbol hierarchy |
| `RenameProvider` | Symbol renaming | Custom rename constraints |
| `ScopeProvider` | Reference resolution scope | Custom scoping rules |
| `ValidationRegistry` | Validation checks | Grammar-specific validators |

### Rationale

- **Inheritance-Based Extension**: Extending `Default*` classes provides access to base functionality while allowing targeted overrides
- **Hierarchical Service Names**: Nested service paths organize services logically and prevent naming collisions
- **Constructor Injection**: Services receive the entire services container, enabling access to any other service

### Alternatives Considered

| Alternative | Reason Rejected |
|-------------|-----------------|
| Monkey-patching defaults | Breaks encapsulation; incompatible with TypeScript's type system |
| Decorator pattern at runtime | Langium's module system already provides cleaner composition |

---

## 3. GLSP Server 2.x Integration with Langium

### Decision

Implement a **Langium-backed GLSP server** using `@eclipse-glsp/server-node` with these components:

**Architecture**:
```
┌─────────────────────────────────────────────────────────┐
│                    Unified Server                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  LSP Handler │  │ GLSP Server  │  │  Model API   │  │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │
│         │                 │                  │          │
│  ┌──────┴─────────────────┴──────────────────┴───────┐  │
│  │            Langium Document Store                 │  │
│  │         (Single Source of Truth)                  │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

**Key Components**:

1. **LangiumModelState** (extends `DefaultGModelState`): Wraps Langium document as source model
2. **LangiumSourceModelStorage** (implements `SourceModelStorage`): Loads/saves via Langium documents
3. **ManifestDrivenGModelFactory** (implements `GModelFactory`): Converts AST to GModel using manifest configuration

**Bidirectional Synchronization**:
- **Text → Diagram**: Listen to Langium document changes, regenerate GModel
- **Diagram → Text**: Operation handlers modify AST, serialize back to text

### Rationale

- **Single Process**: Avoids IPC overhead; Node.js handles both LSP and GLSP efficiently
- **Langium as Source of Truth**: The parsed AST in LangiumDocuments is always authoritative
- **Manifest-Driven**: Existing `GrammarManifest` defines diagram types, node shapes, and tool palettes
- **Operation Handler Pattern**: GLSP's handler architecture maps cleanly to AST modifications

### Alternatives Considered

| Alternative | Reason Rejected |
|-------------|-----------------|
| Separate GLSP server process | Adds IPC complexity; synchronization becomes harder |
| JSON files as source model | Duplicates Langium's document store; creates sync issues |
| EMF-based model | Not TypeScript-native; requires Java runtime or interop |

---

## 4. LSP 3.17 Feature Coverage

### Decision

Implement default providers for **all LSP 3.17 features** organized by category. Grammar packages override specific features while inheriting defaults.

### Complete Feature List

#### Navigation Features
| Feature | Method | Default Implementation |
|---------|--------|------------------------|
| Declaration | `textDocument/declaration` | Navigate to AST node declaration |
| Definition | `textDocument/definition` | Use Langium's reference resolution |
| Type Definition | `textDocument/typeDefinition` | Navigate to type's AST node |
| Implementation | `textDocument/implementation` | Find implementing nodes |
| References | `textDocument/references` | Use Langium's ReferenceFinder |

#### Hierarchy Features
| Feature | Method | Default Implementation |
|---------|--------|------------------------|
| Call Hierarchy | `textDocument/prepareCallHierarchy` | Build call graph from AST |
| Type Hierarchy | `textDocument/prepareTypeHierarchy` | Build inheritance graph |

#### Display Features
| Feature | Method | Default Implementation |
|---------|--------|------------------------|
| Document Highlight | `textDocument/documentHighlight` | Highlight same-name occurrences |
| Hover | `textDocument/hover` | Show AST node name + type + doc |
| Folding Range | `textDocument/foldingRange` | Fold block structures |
| Selection Range | `textDocument/selectionRange` | Expand by AST hierarchy |
| Document Symbols | `textDocument/documentSymbol` | Map AST to hierarchical symbols |
| Semantic Tokens | `textDocument/semanticTokens/full` | Use grammar token types |

#### Edit Features
| Feature | Method | Default Implementation |
|---------|--------|------------------------|
| Completion | `textDocument/completion` | Use Langium's CompletionProvider |
| Code Action | `textDocument/codeAction` | Quick fixes from validators |
| Formatting | `textDocument/formatting` | Use Langium's Formatter |
| Rename | `textDocument/rename` | Use Langium's RenameProvider |
| Linked Editing | `textDocument/linkedEditingRange` | Edit matching pairs |

#### Hints Features
| Feature | Method | Default Implementation |
|---------|--------|------------------------|
| Inlay Hint | `textDocument/inlayHint` | Show type annotations |
| Inline Value | `textDocument/inlineValue` | Return empty (disabled) |
| Code Lens | `textDocument/codeLens` | Reference counts |

### Rationale

- **Completeness**: Users expect modern IDE features; defaults prevent "feature gaps"
- **Override Pattern**: Grammar packages selectively override via typed interfaces
- **Langium Foundation**: Most defaults delegate to existing Langium services

### Alternatives Considered

| Alternative | Reason Rejected |
|-------------|-----------------|
| Implement only common features | Users would hit missing features unexpectedly |
| Require grammar packages to implement all | Excessive boilerplate for simple languages |

---

## 5. Build-time Grammar Discovery

### Decision

Implement a **build-time scanner** that:

1. Parses `pnpm-workspace.yaml` to find package glob patterns
2. Resolves package directories matching `grammars/*`
3. Reads each `package.json` for a `sanyam` field or naming convention
4. Generates a registry manifest at build time

**Package.json Convention**:
```json
{
    "name": "@sanyam/grammar-ecml",
    "sanyam": {
        "grammar": true,
        "languageId": "ecml",
        "contribution": "./lib/contribution.js"
    }
}
```

**Generated Output**:
```typescript
// packages/sanyam-lsp/src/generated/grammar-registry.ts
// AUTO-GENERATED - DO NOT EDIT
import { contribution as ecml } from '@sanyam/grammar-ecml/contribution';
import { contribution as actone } from '@sanyam/grammar-actone/contribution';

export const GRAMMAR_REGISTRY = [
  ecml,
  actone
];
```

### Rationale

- **Build-time Resolution**: Avoids runtime filesystem scanning; improves startup performance
- **pnpm Workspace Alignment**: Uses the same glob patterns pnpm already understands
- **Convention over Configuration**: `@sanyam/grammar-*` naming provides default discovery
- **Generated Code**: Static imports enable tree-shaking and type safety

### Alternatives Considered

| Alternative | Reason Rejected |
|-------------|-----------------|
| Runtime directory scanning | Slower startup; incompatible with bundled deployments |
| Manual registry file | Requires manual updates; error-prone |
| Tags in package.json keywords | Less explicit; harder to query programmatically |

---

## 6. VSIX Packaging for Multi-Language Server

### Decision

Create a **single VSIX extension** with:

1. **Generated `package.json` contributions** based on discovered grammars
2. **`onLanguage:*` activation events** for each registered language
3. **Single language server** that handles all languages
4. **TextMate grammars** generated from Langium at build time

**Extension manifest structure**:
```json
{
    "name": "sanyam-languages",
    "activationEvents": [
        "onLanguage:ecml",
        "onLanguage:actone"
    ],
    "contributes": {
        "languages": [
            {
                "id": "ecml",
                "extensions": [".ecml"],
                "configuration": "./language-configurations/ecml.json"
            }
        ],
        "grammars": [
            {
                "language": "ecml",
                "scopeName": "source.ecml",
                "path": "./syntaxes/ecml.tmLanguage.json"
            }
        ]
    },
    "main": "./dist/extension.js"
}
```

### Rationale

- **Single VSIX**: Simplifies distribution; users install one extension for all DSL support
- **Generated Manifest**: Ensures contributions match discovered grammars
- **Shared Server**: All languages use one server process, reducing resource usage
- **TextMate for Syntax**: Langium generates TextMate grammars for highlighting before server connects

### Alternatives Considered

| Alternative | Reason Rejected |
|-------------|-----------------|
| One VSIX per language | Installation complexity; harder to manage dependencies |
| Dynamic language registration | VS Code's contribute API is static; can't add languages at runtime |
| Wildcard activation (`*`) | Activates on every file; wasteful and slow |

---

## Summary of Decisions

| Topic | Decision | Key Benefit |
|-------|----------|-------------|
| Langium Modules | Layered composition with `inject()` | Type-safe, lazy, cycle-protected DI |
| Service Extension | Interface-based overrides in custom modules | Clean separation of generated/custom code |
| GLSP Integration | Langium DocumentStore as source of truth | Single process, bidirectional sync |
| LSP Coverage | Defaults for all 3.17 features | Complete IDE experience out-of-box |
| Grammar Discovery | Build-time pnpm workspace scanning | Fast startup, tree-shakeable imports |
| VSIX Packaging | Generated manifest, single server | Simple installation, resource efficient |
