/******************************************************************************
 * This file was generated by langium-cli 4.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const Iso42001Terminals = {
    ID: /[_a-zA-Z][\w_]*/,
    STRING: /"[^"]*"|'[^']*'/,
    DATE: /\d{4}-\d{2}-\d{2}/,
    INT: /[0-9]+/,
    BOOLEAN: /true|false/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};

export type Iso42001TerminalNames = keyof typeof Iso42001Terminals;

export type Iso42001KeywordNames =
    | ","
    | "."
    | ".*"
    | ":"
    | "ACCEPT"
    | "ACCESS"
    | "ACCOUNTABILITY"
    | "ACHIEVED"
    | "ADVANCED"
    | "ADVOCACY_GROUP"
    | "AFFECTED_INDIVIDUAL"
    | "AI_MODEL_PROVIDER"
    | "AI_SYSTEM_OPERATOR"
    | "ALGORITHM_BIAS"
    | "ALMOST_CERTAIN"
    | "API"
    | "APPROVED"
    | "ARCHIVED"
    | "ASSESSMENT"
    | "AUGMENTED"
    | "AUTOMATION"
    | "AUTONOMY"
    | "AVAILABILITY"
    | "AVOID"
    | "AWARENESS"
    | "BASIC"
    | "BIAS_DETECTION"
    | "CANCELLED"
    | "CAPABILITY_BUILDING"
    | "CARBON_EMISSIONS"
    | "CATASTROPHIC"
    | "CERTIFICATE"
    | "CERTIFICATION"
    | "CERTIFIED"
    | "CIVIL_RIGHTS"
    | "CLOSED"
    | "CLOUD_PROVIDER"
    | "COMMUNITY"
    | "COMPETITIVE"
    | "COMPLAINT"
    | "COMPLETED"
    | "COMPLIANCE"
    | "COMPLIANCE_VIOLATION"
    | "COMPUTER_VISION"
    | "CONCEPT"
    | "CONFIDENTIAL"
    | "CONFIGURATION"
    | "CONFIGURATION_ERROR"
    | "CONSENT"
    | "CONSULTING"
    | "CONTAINED"
    | "CONTRACT"
    | "CONTRACTUAL"
    | "CRITICAL"
    | "CRITICAL_INFRASTRUCTURE"
    | "CULTURAL"
    | "CURRENT"
    | "CUSTOMER"
    | "CYBER_THREATS"
    | "DATASET"
    | "DATA_BREACH"
    | "DATA_ISSUE"
    | "DATA_PROVIDER"
    | "DATA_QUALITY"
    | "DATA_SUBJECT"
    | "DECREASING"
    | "DEEP_LEARNING"
    | "DEFERRED"
    | "DEFINED"
    | "DEMOCRATIC_PROCESSES"
    | "DEPLOYMENT"
    | "DEPRECATED"
    | "DESIGN"
    | "DETECTED"
    | "DEVELOPMENT"
    | "DIGNITY"
    | "DISCRIMINATION"
    | "DRAFT"
    | "ECONOMIC"
    | "ECONOMIC_INEQUALITY"
    | "EDUCATION"
    | "EMPLOYEE"
    | "EMPLOYMENT"
    | "ENERGY"
    | "ENERGY_CONSUMPTION"
    | "ENTERPRISE"
    | "ENVIRONMENT"
    | "ENVIRONMENTAL"
    | "ESCALATED"
    | "ESSENTIAL"
    | "ETHICAL"
    | "EU_AI_ACT"
    | "EXCELLENT"
    | "EXPERT"
    | "EXPERT_SYSTEM"
    | "EXPIRED"
    | "EXPLAINABILITY"
    | "EXTERNAL"
    | "EXTERNAL_ATTACK"
    | "EXTERNAL_AUDIT"
    | "E_WASTE"
    | "FAILED"
    | "FAIR"
    | "FAIRNESS"
    | "FAIRNESS_CONCERNS"
    | "FEDERATED"
    | "FINANCE"
    | "FINANCIAL"
    | "FINE_TUNING"
    | "FORM"
    | "FRAMEWORK"
    | "FULLY_AUTONOMOUS"
    | "FULLY_IMPLEMENTED"
    | "FULL_CONFORMITY"
    | "FUNCTIONAL"
    | "FURTHER_ASSESSMENT_REQUIRED"
    | "GENERATIVE_AI"
    | "GEOGRAPHICAL"
    | "GLOBAL"
    | "GOOD"
    | "GOVERNMENT"
    | "GPAI"
    | "GUIDELINE"
    | "HALT"
    | "HARDWARE_PROVIDER"
    | "HEALTHCARE"
    | "HIGH"
    | "HIGH_RISK"
    | "HUMAN_ERROR"
    | "HUMAN_IN_THE_LOOP"
    | "HUMAN_ON_THE_LOOP"
    | "HUMAN_OUT_OF_THE_LOOP"
    | "HUMAN_OVERSIGHT"
    | "HYBRID"
    | "IMPLEMENTED"
    | "IMPORTANT"
    | "IMPROVEMENT"
    | "INCIDENT"
    | "INCONCLUSIVE"
    | "INCREASING"
    | "INFERENCE"
    | "INFRASTRUCTURE"
    | "INITIAL"
    | "INTEGRATED"
    | "INTEGRATION"
    | "INTEGRATION_FAILURE"
    | "INTEGRATION_ISSUES"
    | "INTERMEDIATE"
    | "INTERNAL"
    | "INTERNAL_AUDIT"
    | "INTERVIEW"
    | "INVESTIGATING"
    | "IN_PROGRESS"
    | "IN_REVIEW"
    | "IRREVERSIBLE"
    | "ISO_14001"
    | "ISO_22301"
    | "ISO_27001"
    | "ISO_27701"
    | "ISO_31000"
    | "ISO_9001"
    | "LABELED"
    | "LABOR_MARKET"
    | "LACK_OF_TRANSPARENCY"
    | "LARGE"
    | "LEGAL"
    | "LEGAL_OBLIGATION"
    | "LEGAL_REGULATORY"
    | "LEGITIMATE_INTERESTS"
    | "LEVEL_OF_AUTOMATION"
    | "LIBRARY"
    | "LIKELY"
    | "LIMITED"
    | "LIMITED_RISK"
    | "LOCAL"
    | "LOG"
    | "LOW"
    | "MACHINE_LEARNING"
    | "MACHINE_LEARNING_RISKS"
    | "MAINTENANCE"
    | "MAJOR"
    | "MAJOR_NC"
    | "MAJOR_NONCONFORMITIES"
    | "MANAGED"
    | "MANAGEMENT_REVIEW"
    | "MANUFACTURING"
    | "MARKET_DYNAMICS"
    | "MEDIA"
    | "MEDIUM"
    | "MINIMAL"
    | "MINIMAL_RISK"
    | "MINOR"
    | "MINOR_NC"
    | "MINOR_NONCONFORMITIES"
    | "MISUSE"
    | "MITIGATE"
    | "MODEL"
    | "MODEL_DRIFT"
    | "MODEL_FAILURE"
    | "MODEL_ISSUE"
    | "MODERATE"
    | "MONITORING"
    | "NATIONAL"
    | "NATURAL_LANGUAGE_PROCESSING"
    | "NEGLIGIBLE"
    | "NIST_AI_RMF"
    | "NON_CRITICAL"
    | "NORMAL"
    | "NOT_ACHIEVED"
    | "NOT_APPLICABLE"
    | "NOT_ASSESSED"
    | "NOT_IMPLEMENTED"
    | "NOT_STARTED"
    | "NOT_TESTED"
    | "OBJECTIVE_UPDATE"
    | "OBSERVATION"
    | "OBSOLETE"
    | "ON_HOLD"
    | "OPEN"
    | "OPERATION"
    | "OPERATIONAL"
    | "OPPORTUNITY"
    | "OPTIMIZING"
    | "ORGANIZATIONAL"
    | "OTHER"
    | "OVERDUE"
    | "PARTIALLY_IMPLEMENTED"
    | "PARTIALLY_PASSED"
    | "PARTIALLY_REVERSIBLE"
    | "PARTNER"
    | "PASSED"
    | "PENDING"
    | "PENDING_REVIEW"
    | "PERFORMANCE"
    | "PERFORMANCE_DEGRADATION"
    | "PERSONAL"
    | "PILOT"
    | "PLAN"
    | "PLANNED"
    | "POLICY"
    | "POLICY_CHANGE"
    | "POOR"
    | "POSSIBLE"
    | "POSTPONED"
    | "POST_MORTEM"
    | "PRIVACY"
    | "PRIVACY_VIOLATIONS"
    | "PROCEDURE"
    | "PROCEED"
    | "PROCEED_WITH_CONDITIONS"
    | "PROCESS"
    | "PROCESS_FAILURE"
    | "PROCESS_IMPROVEMENT"
    | "PRODUCT"
    | "PRODUCTION"
    | "PROFESSIONAL_SERVICES"
    | "PROHIBITED"
    | "PROPOSED"
    | "PSYCHOLOGICAL"
    | "PUBLIC"
    | "PUBLIC_SAFETY"
    | "PUBLIC_TASK"
    | "PUBLISHED"
    | "QUANTITATIVELY_MANAGED"
    | "RARE"
    | "RECORD"
    | "REGIONAL"
    | "REGULATOR"
    | "REGULATORY"
    | "REGULATORY_CHANGE"
    | "REINFORCEMENT"
    | "REINFORCEMENT_LEARNING"
    | "RELIABILITY"
    | "REPORT"
    | "REPUTATIONAL"
    | "REQUIRES_UPDATE"
    | "RESOLVED"
    | "RESOURCE_ALLOCATION"
    | "RESOURCE_DEPLETION"
    | "RESTRICTED"
    | "RETAIL"
    | "RETIRED"
    | "RETIREMENT"
    | "REVERSIBLE"
    | "RISK_TREATMENT"
    | "ROBOTICS"
    | "ROBUSTNESS"
    | "SAFETY"
    | "SAFETY_ISSUE"
    | "SCALABILITY"
    | "SCREENSHOT"
    | "SECURITY"
    | "SECURITY_BREACH"
    | "SELF_ASSESSMENT"
    | "SEMI_SUPERVISED"
    | "SENSITIVE_PERSONAL"
    | "SERVICE"
    | "SEVERE"
    | "SHAREHOLDER"
    | "SIGNIFICANT"
    | "SKILL_GAPS"
    | "SMALL"
    | "SOC2"
    | "SOCIAL"
    | "SOCIAL_COHESION"
    | "SOCIETAL"
    | "SOFTWARE_PROVIDER"
    | "SPECIAL_CATEGORY"
    | "SPECIFICATION"
    | "STABLE"
    | "STANDARD"
    | "STARTUP"
    | "STRATEGIC"
    | "STRENGTH"
    | "SUPERSEDED"
    | "SUPERVISED"
    | "SUPPLIER"
    | "SURVEILLANCE"
    | "SUSTAINABILITY"
    | "SYNTHETIC"
    | "SYSTEM_COMPLEXITY"
    | "SYSTEM_HARDWARE"
    | "TECHNICAL"
    | "TECHNOLOGICAL"
    | "TECHNOLOGY"
    | "TECHNOLOGY_READINESS"
    | "TECHNOLOGY_UPGRADE"
    | "TELECOMMUNICATIONS"
    | "TEMPLATE"
    | "TEST"
    | "TESTING"
    | "TEST_RESULT"
    | "THIRD_PARTY"
    | "THIRD_PARTY_DEPENDENCY"
    | "TRAINING"
    | "TRAINING_MATERIAL"
    | "TRANSFER"
    | "TRANSFER_LEARNING"
    | "TRANSPARENCY"
    | "TRANSPORTATION"
    | "TRIAGED"
    | "UI"
    | "UNACCEPTABLE"
    | "UNASSESSED"
    | "UNDER_REVISION"
    | "UNINTENDED_BEHAVIOR"
    | "UNINTENDED_CONSEQUENCES"
    | "UNKNOWN"
    | "UNLABELED"
    | "UNLIKELY"
    | "UNSUPERVISED"
    | "UNVERIFIED"
    | "USER"
    | "VALIDATION"
    | "VERIFICATION"
    | "VERIFIED"
    | "VERY_HIGH"
    | "VERY_LOW"
    | "VITAL_INTERESTS"
    | "WARNING"
    | "WATER_USAGE"
    | "[X]"
    | "accuracy"
    | "acquisition"
    | "action"
    | "actualBenefits"
    | "actualDate"
    | "affectedGroups"
    | "affectedParties"
    | "affectedSystem"
    | "affectedSystems"
    | "affectedUsers"
    | "aiImplications"
    | "aiPoliciesReviewed"
    | "aiRequirements"
    | "aiRoles"
    | "aiSystem"
    | "aiSystems"
    | "aims"
    | "aimsPerformance"
    | "aimsRef"
    | "applicable"
    | "approvalDate"
    | "approvedBy"
    | "approver"
    | "assessed"
    | "assessment"
    | "assessmentDate"
    | "assessor"
    | "assignedTo"
    | "audit"
    | "auditProgram"
    | "auditResults"
    | "auditRights"
    | "auditTeam"
    | "augmentation"
    | "authority"
    | "autonomyLevel"
    | "basedOn"
    | "baseline"
    | "beneficiaries"
    | "benefit"
    | "benefits"
    | "biasAssessment"
    | "boundaries"
    | "boundary"
    | "businessImpact"
    | "category"
    | "certifications"
    | "chairperson"
    | "changesAffectingAIMS"
    | "classification"
    | "clause"
    | "collectedBy"
    | "collectedDate"
    | "commitments"
    | "communication"
    | "communicationRecord"
    | "companyName"
    | "competencies"
    | "completedDate"
    | "completeness"
    | "complianceVerified"
    | "component"
    | "components"
    | "computing"
    | "conclusion"
    | "conditions"
    | "conformityLevel"
    | "consentObtained"
    | "consistency"
    | "containment"
    | "context"
    | "contract"
    | "control"
    | "controlCatalog"
    | "controls"
    | "correctiveAction"
    | "createdDate"
    | "criteria"
    | "criticality"
    | "currentValue"
    | "data"
    | "dataInventory"
    | "dataProtectionClause"
    | "dataResources"
    | "dataset"
    | "date"
    | "deadline"
    | "decision"
    | "declare"
    | "deploymentDate"
    | "description"
    | "detectedDate"
    | "document"
    | "documentRegistry"
    | "documents"
    | "dueDate"
    | "dueDiligence"
    | "effectiveDate"
    | "effectiveness"
    | "endDate"
    | "environmentalImpacts"
    | "ethicsReviewed"
    | "euAiActCategory"
    | "evidence"
    | "exclusion"
    | "exclusions"
    | "expectations"
    | "expectedBenefits"
    | "external"
    | "family"
    | "finding"
    | "findings"
    | "foreseeableMisuse"
    | "frequency"
    | "gapAnalysis"
    | "guidance"
    | "immediateAction"
    | "immediateActions"
    | "impact"
    | "impactAssessment"
    | "impactAssessments"
    | "implementation"
    | "implementationNotes"
    | "import"
    | "improvementPlan"
    | "incident"
    | "incidentNotification"
    | "incidentRegistry"
    | "indicator"
    | "indicators"
    | "individualImpacts"
    | "industry"
    | "influence"
    | "infrastructure"
    | "inherentRisk"
    | "initiative"
    | "initiatives"
    | "inputs"
    | "integration"
    | "intendedUse"
    | "interest"
    | "internal"
    | "internalNotified"
    | "issue"
    | "issues"
    | "justification"
    | "labeling"
    | "lastReviewDate"
    | "lastVerified"
    | "leadAuditor"
    | "legalBasis"
    | "lessonLearned"
    | "license"
    | "lifecycle"
    | "likelihood"
    | "lineage"
    | "location"
    | "locations"
    | "managementReview"
    | "managementSystems"
    | "mappings"
    | "maps"
    | "maturity"
    | "measure"
    | "member"
    | "method"
    | "methodology"
    | "methods"
    | "metric"
    | "mitigates"
    | "mitigation"
    | "mitigations"
    | "mlApproach"
    | "monitoring"
    | "monitoringResults"
    | "needs"
    | "nextReview"
    | "nextReviewDate"
    | "nonconformities"
    | "nonconformity"
    | "notes"
    | "objective"
    | "objectives"
    | "operationalContext"
    | "opportunitiesForImprovement"
    | "organization"
    | "origin"
    | "outputs"
    | "overallRating"
    | "overallRiskLevel"
    | "owner"
    | "participants"
    | "performanceRating"
    | "period"
    | "plannedDate"
    | "policy"
    | "preparation"
    | "preventiveAction"
    | "previousActionsStatus"
    | "principle"
    | "principles"
    | "priority"
    | "provenance"
    | "provider"
    | "purpose"
    | "quality"
    | "recommendation"
    | "recommendations"
    | "ref"
    | "regulatorsNotified"
    | "relatedControls"
    | "relatedObjectives"
    | "relevance"
    | "reportedBy"
    | "reportedDate"
    | "requirements"
    | "residualRisk"
    | "resolvedDate"
    | "resourceAdequacy"
    | "resources"
    | "response"
    | "responsibilities"
    | "responsible"
    | "result"
    | "retentionPeriod"
    | "retirementDate"
    | "reversibility"
    | "reviewDate"
    | "reviewer"
    | "risk"
    | "riskAssessmentResults"
    | "riskCategories"
    | "riskLevel"
    | "riskRegistry"
    | "role"
    | "rootCause"
    | "rootCauseAnalysis"
    | "scale"
    | "scope"
    | "securityAssessed"
    | "sensitivity"
    | "services"
    | "severity"
    | "sharedElements"
    | "significance"
    | "size"
    | "soa"
    | "societalImpacts"
    | "source"
    | "stage"
    | "stakeholder"
    | "stakeholderFeedback"
    | "stakeholderRegistry"
    | "stakeholders"
    | "startDate"
    | "statement"
    | "status"
    | "strategy"
    | "summary"
    | "supplier"
    | "supplierRegistry"
    | "suppliers"
    | "target"
    | "targetDate"
    | "team"
    | "thirdPartyProvider"
    | "threshold"
    | "timeliness"
    | "title"
    | "tool"
    | "tooling"
    | "transformations"
    | "treatment"
    | "trend"
    | "type"
    | "updateFrequency"
    | "usedBy"
    | "usersNotified"
    | "validity"
    | "verification"
    | "version"
    | "volume"
    | "year"
    | "{"
    | "}";

export type Iso42001TokenNames = Iso42001TerminalNames | Iso42001KeywordNames;

export interface AIComponent extends langium.AstNode {
    readonly $container: AISystem;
    readonly $type: 'AIComponent';
    description?: string;
    license?: string;
    name: string;
    provider?: string;
    type: ComponentType;
    version?: string;
}

export const AIComponent = {
    $type: 'AIComponent',
    description: 'description',
    license: 'license',
    name: 'name',
    provider: 'provider',
    type: 'type',
    version: 'version'
} as const;

export function isAIComponent(item: unknown): item is AIComponent {
    return reflection.isInstance(item, AIComponent.$type);
}

export interface AIIncident extends langium.AstNode {
    readonly $container: IncidentRegistry;
    readonly $type: 'AIIncident';
    affectedSystem?: langium.Reference<AISystem>;
    affectedUsers?: number;
    businessImpact?: string;
    communicationRecord?: string;
    containment?: string;
    description: string;
    detectedDate: string;
    immediateActions?: string;
    impactDesc?: string;
    internalNotified: boolean;
    lessonLearned?: string;
    name: string;
    regulatorsNotified: boolean;
    reportedBy?: string;
    resolvedDate?: string;
    rootCause?: IncidentRootCause;
    severity?: IncidentSeverity;
    status?: IncidentStatus;
    type?: IncidentType;
    usersNotified: boolean;
}

export const AIIncident = {
    $type: 'AIIncident',
    affectedSystem: 'affectedSystem',
    affectedUsers: 'affectedUsers',
    businessImpact: 'businessImpact',
    communicationRecord: 'communicationRecord',
    containment: 'containment',
    description: 'description',
    detectedDate: 'detectedDate',
    immediateActions: 'immediateActions',
    impactDesc: 'impactDesc',
    internalNotified: 'internalNotified',
    lessonLearned: 'lessonLearned',
    name: 'name',
    regulatorsNotified: 'regulatorsNotified',
    reportedBy: 'reportedBy',
    resolvedDate: 'resolvedDate',
    rootCause: 'rootCause',
    severity: 'severity',
    status: 'status',
    type: 'type',
    usersNotified: 'usersNotified'
} as const;

export function isAIIncident(item: unknown): item is AIIncident {
    return reflection.isInstance(item, AIIncident.$type);
}

export interface AIManagementSystem extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'AIManagementSystem';
    aiSystemRefs: Array<langium.Reference<AISystem>>;
    approvalDate?: string;
    approvedBy?: string;
    boundaries: Array<ScopeBoundary>;
    commitments: Array<string>;
    documentRefs: Array<langium.Reference<Document>>;
    effectiveDate?: string;
    exclusions: Array<ScopeExclusion>;
    name: string;
    objectives: Array<AIObjective>;
    organization?: langium.Reference<Organization>;
    policyStatement?: string;
    principles: Array<AIPrinciple>;
    reviewDate?: string;
    scopeDescription?: string;
    version: string;
}

export const AIManagementSystem = {
    $type: 'AIManagementSystem',
    aiSystemRefs: 'aiSystemRefs',
    approvalDate: 'approvalDate',
    approvedBy: 'approvedBy',
    boundaries: 'boundaries',
    commitments: 'commitments',
    documentRefs: 'documentRefs',
    effectiveDate: 'effectiveDate',
    exclusions: 'exclusions',
    name: 'name',
    objectives: 'objectives',
    organization: 'organization',
    policyStatement: 'policyStatement',
    principles: 'principles',
    reviewDate: 'reviewDate',
    scopeDescription: 'scopeDescription',
    version: 'version'
} as const;

export function isAIManagementSystem(item: unknown): item is AIManagementSystem {
    return reflection.isInstance(item, AIManagementSystem.$type);
}

export interface AIObjective extends langium.AstNode {
    readonly $container: AIManagementSystem;
    readonly $type: 'AIObjective';
    baseline?: string;
    controlRefs: Array<langium.Reference<Control>>;
    deadline?: string;
    description: string;
    metric?: string;
    name: string;
    owner?: string;
    status?: ObjectiveStatus;
    target?: string;
}

export const AIObjective = {
    $type: 'AIObjective',
    baseline: 'baseline',
    controlRefs: 'controlRefs',
    deadline: 'deadline',
    description: 'description',
    metric: 'metric',
    name: 'name',
    owner: 'owner',
    status: 'status',
    target: 'target'
} as const;

export function isAIObjective(item: unknown): item is AIObjective {
    return reflection.isInstance(item, AIObjective.$type);
}

export interface AIPrinciple extends langium.AstNode {
    readonly $container: AIManagementSystem;
    readonly $type: 'AIPrinciple';
    category?: PrincipleCategory;
    description: string;
    implementation?: string;
    name: string;
}

export const AIPrinciple = {
    $type: 'AIPrinciple',
    category: 'category',
    description: 'description',
    implementation: 'implementation',
    name: 'name'
} as const;

export function isAIPrinciple(item: unknown): item is AIPrinciple {
    return reflection.isInstance(item, AIPrinciple.$type);
}

export type AIRiskCategory = 'ENVIRONMENTAL' | 'ETHICAL' | 'FINANCIAL' | 'LEGAL_REGULATORY' | 'OPERATIONAL' | 'PRIVACY' | 'REPUTATIONAL' | 'SAFETY' | 'SECURITY' | 'SOCIETAL' | 'STRATEGIC' | 'TECHNICAL';

export function isAIRiskCategory(item: unknown): item is AIRiskCategory {
    return item === 'TECHNICAL' || item === 'OPERATIONAL' || item === 'ETHICAL' || item === 'LEGAL_REGULATORY' || item === 'REPUTATIONAL' || item === 'FINANCIAL' || item === 'STRATEGIC' || item === 'SAFETY' || item === 'SECURITY' || item === 'PRIVACY' || item === 'ENVIRONMENTAL' || item === 'SOCIETAL';
}

export type AIRiskSource = 'ALGORITHM_BIAS' | 'CYBER_THREATS' | 'DATA_QUALITY' | 'FAIRNESS_CONCERNS' | 'HUMAN_ERROR' | 'INTEGRATION_ISSUES' | 'LACK_OF_TRANSPARENCY' | 'LEVEL_OF_AUTOMATION' | 'MACHINE_LEARNING_RISKS' | 'MARKET_DYNAMICS' | 'MISUSE' | 'MODEL_DRIFT' | 'OTHER' | 'PRIVACY_VIOLATIONS' | 'PROCESS_FAILURE' | 'REGULATORY_CHANGE' | 'SCALABILITY' | 'SKILL_GAPS' | 'SYSTEM_COMPLEXITY' | 'SYSTEM_HARDWARE' | 'TECHNOLOGY_READINESS' | 'THIRD_PARTY_DEPENDENCY' | 'UNINTENDED_CONSEQUENCES';

export function isAIRiskSource(item: unknown): item is AIRiskSource {
    return item === 'ALGORITHM_BIAS' || item === 'DATA_QUALITY' || item === 'MODEL_DRIFT' || item === 'SYSTEM_COMPLEXITY' || item === 'LACK_OF_TRANSPARENCY' || item === 'LEVEL_OF_AUTOMATION' || item === 'MACHINE_LEARNING_RISKS' || item === 'SYSTEM_HARDWARE' || item === 'TECHNOLOGY_READINESS' || item === 'HUMAN_ERROR' || item === 'SKILL_GAPS' || item === 'PROCESS_FAILURE' || item === 'INTEGRATION_ISSUES' || item === 'SCALABILITY' || item === 'REGULATORY_CHANGE' || item === 'MARKET_DYNAMICS' || item === 'THIRD_PARTY_DEPENDENCY' || item === 'CYBER_THREATS' || item === 'FAIRNESS_CONCERNS' || item === 'PRIVACY_VIOLATIONS' || item === 'UNINTENDED_CONSEQUENCES' || item === 'MISUSE' || item === 'OTHER';
}

export interface AIRole extends langium.AstNode {
    readonly $container: Organization;
    readonly $type: 'AIRole';
    assignedTo?: string;
    authority?: string;
    competencies: Array<Competency>;
    name: string;
    responsibilities: Array<string>;
    title: string;
}

export const AIRole = {
    $type: 'AIRole',
    assignedTo: 'assignedTo',
    authority: 'authority',
    competencies: 'competencies',
    name: 'name',
    responsibilities: 'responsibilities',
    title: 'title'
} as const;

export function isAIRole(item: unknown): item is AIRole {
    return reflection.isInstance(item, AIRole.$type);
}

export interface AISystem extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'AISystem';
    affectedParties: Array<string>;
    autonomyLevel?: AutonomyLevel;
    beneficiaries: Array<string>;
    components: Array<AIComponent>;
    dataResources: Array<DataResource>;
    deploymentDate?: string;
    description: string;
    euAiActCategory?: EUAIActCategory;
    foreseeableMisuse?: string;
    impactAssessmentRefs: Array<langium.Reference<ImpactAssessment>>;
    infrastructure?: string;
    intendedUse?: string;
    lifecycleStage?: LifecycleStage;
    mlApproach?: MLApproach;
    name: string;
    requirements?: string;
    retirementDate?: string;
    riskLevel?: RiskLevel;
    status?: SystemStatus;
    suppliers: Array<langium.Reference<Supplier>>;
    teamMembers: Array<TeamMember>;
    tools: Array<Tool>;
    type?: AISystemType;
    version?: string;
}

export const AISystem = {
    $type: 'AISystem',
    affectedParties: 'affectedParties',
    autonomyLevel: 'autonomyLevel',
    beneficiaries: 'beneficiaries',
    components: 'components',
    dataResources: 'dataResources',
    deploymentDate: 'deploymentDate',
    description: 'description',
    euAiActCategory: 'euAiActCategory',
    foreseeableMisuse: 'foreseeableMisuse',
    impactAssessmentRefs: 'impactAssessmentRefs',
    infrastructure: 'infrastructure',
    intendedUse: 'intendedUse',
    lifecycleStage: 'lifecycleStage',
    mlApproach: 'mlApproach',
    name: 'name',
    requirements: 'requirements',
    retirementDate: 'retirementDate',
    riskLevel: 'riskLevel',
    status: 'status',
    suppliers: 'suppliers',
    teamMembers: 'teamMembers',
    tools: 'tools',
    type: 'type',
    version: 'version'
} as const;

export function isAISystem(item: unknown): item is AISystem {
    return reflection.isInstance(item, AISystem.$type);
}

export type AISystemType = 'COMPUTER_VISION' | 'DEEP_LEARNING' | 'EXPERT_SYSTEM' | 'GENERATIVE_AI' | 'HYBRID' | 'MACHINE_LEARNING' | 'NATURAL_LANGUAGE_PROCESSING' | 'OTHER' | 'REINFORCEMENT_LEARNING' | 'ROBOTICS';

export function isAISystemType(item: unknown): item is AISystemType {
    return item === 'MACHINE_LEARNING' || item === 'DEEP_LEARNING' || item === 'NATURAL_LANGUAGE_PROCESSING' || item === 'COMPUTER_VISION' || item === 'ROBOTICS' || item === 'EXPERT_SYSTEM' || item === 'GENERATIVE_AI' || item === 'REINFORCEMENT_LEARNING' || item === 'HYBRID' || item === 'OTHER';
}

export type AssessmentDecision = 'FURTHER_ASSESSMENT_REQUIRED' | 'HALT' | 'PROCEED' | 'PROCEED_WITH_CONDITIONS';

export function isAssessmentDecision(item: unknown): item is AssessmentDecision {
    return item === 'PROCEED' || item === 'PROCEED_WITH_CONDITIONS' || item === 'HALT' || item === 'FURTHER_ASSESSMENT_REQUIRED';
}

export interface AssessmentModel extends langium.AstNode {
    readonly $type: 'AssessmentModel';
    elements: Array<ModelElement>;
    imports: Array<Import>;
}

export const AssessmentModel = {
    $type: 'AssessmentModel',
    elements: 'elements',
    imports: 'imports'
} as const;

export function isAssessmentModel(item: unknown): item is AssessmentModel {
    return reflection.isInstance(item, AssessmentModel.$type);
}

export type AssessmentStatus = 'APPROVED' | 'ARCHIVED' | 'DRAFT' | 'IN_REVIEW' | 'REQUIRES_UPDATE';

export function isAssessmentStatus(item: unknown): item is AssessmentStatus {
    return item === 'DRAFT' || item === 'IN_REVIEW' || item === 'APPROVED' || item === 'REQUIRES_UPDATE' || item === 'ARCHIVED';
}

export interface Audit extends langium.AstNode {
    readonly $container: AuditProgram;
    readonly $type: 'Audit';
    actualDate?: string;
    auditTeam: Array<string>;
    conformityLevel?: ConformityLevel;
    criteria?: string;
    findings: Array<AuditFinding>;
    leadAuditor?: string;
    name: string;
    plannedDate?: string;
    recommendations: Array<string>;
    scope?: string;
    status?: AuditStatus;
    summary?: string;
    type: AuditType;
}

export const Audit = {
    $type: 'Audit',
    actualDate: 'actualDate',
    auditTeam: 'auditTeam',
    conformityLevel: 'conformityLevel',
    criteria: 'criteria',
    findings: 'findings',
    leadAuditor: 'leadAuditor',
    name: 'name',
    plannedDate: 'plannedDate',
    recommendations: 'recommendations',
    scope: 'scope',
    status: 'status',
    summary: 'summary',
    type: 'type'
} as const;

export function isAudit(item: unknown): item is Audit {
    return reflection.isInstance(item, Audit.$type);
}

export interface AuditFinding extends langium.AstNode {
    readonly $container: Audit;
    readonly $type: 'AuditFinding';
    actionDescription?: string;
    actionStatus?: CorrectiveActionStatus;
    clause?: string;
    completedDate?: string;
    control?: langium.Reference<Control>;
    description: string;
    dueDate?: string;
    evidence?: string;
    name: string;
    owner?: string;
    rootCause?: string;
    type: FindingType;
    verification?: string;
}

export const AuditFinding = {
    $type: 'AuditFinding',
    actionDescription: 'actionDescription',
    actionStatus: 'actionStatus',
    clause: 'clause',
    completedDate: 'completedDate',
    control: 'control',
    description: 'description',
    dueDate: 'dueDate',
    evidence: 'evidence',
    name: 'name',
    owner: 'owner',
    rootCause: 'rootCause',
    type: 'type',
    verification: 'verification'
} as const;

export function isAuditFinding(item: unknown): item is AuditFinding {
    return reflection.isInstance(item, AuditFinding.$type);
}

export interface AuditProgram extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'AuditProgram';
    audits: Array<Audit>;
    description?: string;
    name: string;
    objectives?: string;
    year?: number;
}

export const AuditProgram = {
    $type: 'AuditProgram',
    audits: 'audits',
    description: 'description',
    name: 'name',
    objectives: 'objectives',
    year: 'year'
} as const;

export function isAuditProgram(item: unknown): item is AuditProgram {
    return reflection.isInstance(item, AuditProgram.$type);
}

export type AuditStatus = 'CANCELLED' | 'COMPLETED' | 'IN_PROGRESS' | 'PLANNED' | 'POSTPONED';

export function isAuditStatus(item: unknown): item is AuditStatus {
    return item === 'PLANNED' || item === 'IN_PROGRESS' || item === 'COMPLETED' || item === 'CANCELLED' || item === 'POSTPONED';
}

export type AuditType = 'CERTIFICATION' | 'CUSTOMER' | 'EXTERNAL' | 'INTERNAL' | 'REGULATORY' | 'SUPPLIER' | 'SURVEILLANCE';

export function isAuditType(item: unknown): item is AuditType {
    return item === 'INTERNAL' || item === 'EXTERNAL' || item === 'CERTIFICATION' || item === 'SURVEILLANCE' || item === 'SUPPLIER' || item === 'CUSTOMER' || item === 'REGULATORY';
}

export type AutonomyLevel = 'FULLY_AUTONOMOUS' | 'HUMAN_IN_THE_LOOP' | 'HUMAN_ON_THE_LOOP' | 'HUMAN_OUT_OF_THE_LOOP';

export function isAutonomyLevel(item: unknown): item is AutonomyLevel {
    return item === 'HUMAN_IN_THE_LOOP' || item === 'HUMAN_ON_THE_LOOP' || item === 'HUMAN_OUT_OF_THE_LOOP' || item === 'FULLY_AUTONOMOUS';
}

export interface Benefit extends langium.AstNode {
    readonly $container: ImpactAssessment;
    readonly $type: 'Benefit';
    beneficiaries: Array<string>;
    description: string;
    name: string;
    significance?: ImpactSeverity;
}

export const Benefit = {
    $type: 'Benefit',
    beneficiaries: 'beneficiaries',
    description: 'description',
    name: 'name',
    significance: 'significance'
} as const;

export function isBenefit(item: unknown): item is Benefit {
    return reflection.isInstance(item, Benefit.$type);
}

export type BoundaryType = 'FUNCTIONAL' | 'GEOGRAPHICAL' | 'ORGANIZATIONAL' | 'PROCESS' | 'PRODUCT' | 'SERVICE' | 'TECHNICAL';

export function isBoundaryType(item: unknown): item is BoundaryType {
    return item === 'GEOGRAPHICAL' || item === 'FUNCTIONAL' || item === 'TECHNICAL' || item === 'ORGANIZATIONAL' || item === 'PROCESS' || item === 'PRODUCT' || item === 'SERVICE';
}

export interface Competency extends langium.AstNode {
    readonly $container: AIRole;
    readonly $type: 'Competency';
    level: CompetencyLevel;
    name: string;
}

export const Competency = {
    $type: 'Competency',
    level: 'level',
    name: 'name'
} as const;

export function isCompetency(item: unknown): item is Competency {
    return reflection.isInstance(item, Competency.$type);
}

export type CompetencyLevel = 'ADVANCED' | 'AWARENESS' | 'BASIC' | 'EXPERT' | 'INTERMEDIATE';

export function isCompetencyLevel(item: unknown): item is CompetencyLevel {
    return item === 'AWARENESS' || item === 'BASIC' || item === 'INTERMEDIATE' || item === 'ADVANCED' || item === 'EXPERT';
}

export type ComponentType = 'API' | 'DATASET' | 'FRAMEWORK' | 'INFRASTRUCTURE' | 'INTEGRATION' | 'LIBRARY' | 'MODEL' | 'OTHER' | 'UI';

export function isComponentType(item: unknown): item is ComponentType {
    return item === 'MODEL' || item === 'FRAMEWORK' || item === 'LIBRARY' || item === 'API' || item === 'DATASET' || item === 'INFRASTRUCTURE' || item === 'UI' || item === 'INTEGRATION' || item === 'OTHER';
}

export type ConformityLevel = 'FULL_CONFORMITY' | 'MAJOR_NONCONFORMITIES' | 'MINOR_NONCONFORMITIES';

export function isConformityLevel(item: unknown): item is ConformityLevel {
    return item === 'FULL_CONFORMITY' || item === 'MINOR_NONCONFORMITIES' || item === 'MAJOR_NONCONFORMITIES';
}

export type ContextCategory = 'COMPETITIVE' | 'CONTRACTUAL' | 'CULTURAL' | 'ECONOMIC' | 'ENVIRONMENTAL' | 'ETHICAL' | 'LEGAL' | 'ORGANIZATIONAL' | 'REGULATORY' | 'SOCIAL' | 'TECHNOLOGICAL';

export function isContextCategory(item: unknown): item is ContextCategory {
    return item === 'LEGAL' || item === 'REGULATORY' || item === 'TECHNOLOGICAL' || item === 'COMPETITIVE' || item === 'CULTURAL' || item === 'SOCIAL' || item === 'ECONOMIC' || item === 'ENVIRONMENTAL' || item === 'ETHICAL' || item === 'ORGANIZATIONAL' || item === 'CONTRACTUAL';
}

export interface ContextIssue extends langium.AstNode {
    readonly $container: Organization;
    readonly $type: 'ContextIssue';
    aiImplications?: string;
    category?: ContextCategory;
    description: string;
    name: string;
    relevance?: RelevanceLevel;
}

export const ContextIssue = {
    $type: 'ContextIssue',
    aiImplications: 'aiImplications',
    category: 'category',
    description: 'description',
    name: 'name',
    relevance: 'relevance'
} as const;

export function isContextIssue(item: unknown): item is ContextIssue {
    return reflection.isInstance(item, ContextIssue.$type);
}

export interface Control extends langium.AstNode {
    readonly $container: ControlFamily;
    readonly $type: 'Control';
    completedDate?: string;
    description?: string;
    dueDate?: string;
    evidence: Array<Evidence>;
    guidance?: string;
    implementationDesc?: string;
    lastVerified?: string;
    mappings: Array<ControlMapping>;
    maturity?: MaturityLevel;
    method?: string;
    mitigatedRisks: Array<langium.Reference<Risk>>;
    name: string;
    objective: string;
    owner?: string;
    status?: ImplementationStatus;
    title: string;
    verificationFrequency?: string;
    verificationMethod?: string;
    verificationNotes?: string;
    verificationResult?: VerificationResult;
}

export const Control = {
    $type: 'Control',
    completedDate: 'completedDate',
    description: 'description',
    dueDate: 'dueDate',
    evidence: 'evidence',
    guidance: 'guidance',
    implementationDesc: 'implementationDesc',
    lastVerified: 'lastVerified',
    mappings: 'mappings',
    maturity: 'maturity',
    method: 'method',
    mitigatedRisks: 'mitigatedRisks',
    name: 'name',
    objective: 'objective',
    owner: 'owner',
    status: 'status',
    title: 'title',
    verificationFrequency: 'verificationFrequency',
    verificationMethod: 'verificationMethod',
    verificationNotes: 'verificationNotes',
    verificationResult: 'verificationResult'
} as const;

export function isControl(item: unknown): item is Control {
    return reflection.isInstance(item, Control.$type);
}

export interface ControlCatalog extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'ControlCatalog';
    basedOn?: string;
    controlFamilies: Array<ControlFamily>;
    description?: string;
    name: string;
    version?: string;
}

export const ControlCatalog = {
    $type: 'ControlCatalog',
    basedOn: 'basedOn',
    controlFamilies: 'controlFamilies',
    description: 'description',
    name: 'name',
    version: 'version'
} as const;

export function isControlCatalog(item: unknown): item is ControlCatalog {
    return reflection.isInstance(item, ControlCatalog.$type);
}

export interface ControlDeclaration extends langium.AstNode {
    readonly $container: StatementOfApplicability;
    readonly $type: 'ControlDeclaration';
    applicable: boolean;
    control: langium.Reference<Control>;
    implementationNotes?: string;
    justification?: string;
}

export const ControlDeclaration = {
    $type: 'ControlDeclaration',
    applicable: 'applicable',
    control: 'control',
    implementationNotes: 'implementationNotes',
    justification: 'justification'
} as const;

export function isControlDeclaration(item: unknown): item is ControlDeclaration {
    return reflection.isInstance(item, ControlDeclaration.$type);
}

export interface ControlFamily extends langium.AstNode {
    readonly $container: ControlCatalog;
    readonly $type: 'ControlFamily';
    controls: Array<Control>;
    description?: string;
    name: string;
    title: string;
}

export const ControlFamily = {
    $type: 'ControlFamily',
    controls: 'controls',
    description: 'description',
    name: 'name',
    title: 'title'
} as const;

export function isControlFamily(item: unknown): item is ControlFamily {
    return reflection.isInstance(item, ControlFamily.$type);
}

export interface ControlMapping extends langium.AstNode {
    readonly $container: Control;
    readonly $type: 'ControlMapping';
    framework: string;
    reference: string;
}

export const ControlMapping = {
    $type: 'ControlMapping',
    framework: 'framework',
    reference: 'reference'
} as const;

export function isControlMapping(item: unknown): item is ControlMapping {
    return reflection.isInstance(item, ControlMapping.$type);
}

export type CorrectiveActionStatus = 'CLOSED' | 'COMPLETED' | 'IN_PROGRESS' | 'OPEN' | 'OVERDUE' | 'VERIFIED';

export function isCorrectiveActionStatus(item: unknown): item is CorrectiveActionStatus {
    return item === 'OPEN' || item === 'IN_PROGRESS' || item === 'COMPLETED' || item === 'VERIFIED' || item === 'CLOSED' || item === 'OVERDUE';
}

export type CriticalityLevel = 'CRITICAL' | 'ESSENTIAL' | 'IMPORTANT' | 'NON_CRITICAL';

export function isCriticalityLevel(item: unknown): item is CriticalityLevel {
    return item === 'NON_CRITICAL' || item === 'IMPORTANT' || item === 'CRITICAL' || item === 'ESSENTIAL';
}

export type DataCategory = 'AUGMENTED' | 'LABELED' | 'PRODUCTION' | 'SYNTHETIC' | 'TEST' | 'TRAINING' | 'UNLABELED' | 'VALIDATION';

export function isDataCategory(item: unknown): item is DataCategory {
    return item === 'TRAINING' || item === 'VALIDATION' || item === 'TEST' || item === 'PRODUCTION' || item === 'SYNTHETIC' || item === 'AUGMENTED' || item === 'LABELED' || item === 'UNLABELED';
}

export interface DataInventory extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'DataInventory';
    datasets: Array<Dataset>;
    description?: string;
    name: string;
}

export const DataInventory = {
    $type: 'DataInventory',
    datasets: 'datasets',
    description: 'description',
    name: 'name'
} as const;

export function isDataInventory(item: unknown): item is DataInventory {
    return reflection.isInstance(item, DataInventory.$type);
}

export type DataPurpose = 'FINE_TUNING' | 'INFERENCE' | 'MONITORING' | 'OTHER' | 'TESTING' | 'TRAINING' | 'VALIDATION';

export function isDataPurpose(item: unknown): item is DataPurpose {
    return item === 'TRAINING' || item === 'VALIDATION' || item === 'TESTING' || item === 'INFERENCE' || item === 'MONITORING' || item === 'FINE_TUNING' || item === 'OTHER';
}

export type DataQuality = 'CERTIFIED' | 'HIGH' | 'LOW' | 'MEDIUM' | 'UNASSESSED';

export function isDataQuality(item: unknown): item is DataQuality {
    return item === 'UNASSESSED' || item === 'LOW' || item === 'MEDIUM' || item === 'HIGH' || item === 'CERTIFIED';
}

export interface DataResource extends langium.AstNode {
    readonly $container: AISystem;
    readonly $type: 'DataResource';
    biasAssessment?: string;
    category: DataCategory;
    description?: string;
    name: string;
    provenance?: string;
    quality?: DataQuality;
    retentionPeriod?: string;
    sensitivity?: DataSensitivity;
    source?: string;
    updateFrequency?: string;
    volume?: string;
}

export const DataResource = {
    $type: 'DataResource',
    biasAssessment: 'biasAssessment',
    category: 'category',
    description: 'description',
    name: 'name',
    provenance: 'provenance',
    quality: 'quality',
    retentionPeriod: 'retentionPeriod',
    sensitivity: 'sensitivity',
    source: 'source',
    updateFrequency: 'updateFrequency',
    volume: 'volume'
} as const;

export function isDataResource(item: unknown): item is DataResource {
    return reflection.isInstance(item, DataResource.$type);
}

export type DataSensitivity = 'CONFIDENTIAL' | 'INTERNAL' | 'PERSONAL' | 'PUBLIC' | 'RESTRICTED' | 'SENSITIVE_PERSONAL' | 'SPECIAL_CATEGORY';

export function isDataSensitivity(item: unknown): item is DataSensitivity {
    return item === 'PUBLIC' || item === 'INTERNAL' || item === 'CONFIDENTIAL' || item === 'RESTRICTED' || item === 'PERSONAL' || item === 'SENSITIVE_PERSONAL' || item === 'SPECIAL_CATEGORY';
}

export interface Dataset extends langium.AstNode {
    readonly $container: DataInventory;
    readonly $type: 'Dataset';
    accuracy?: QualityRating;
    aiSystemRefs: Array<langium.Reference<AISystem>>;
    assessed: boolean;
    augmentation?: string;
    completeness?: QualityRating;
    consentObtained: boolean;
    consistency?: QualityRating;
    description: string;
    findings?: string;
    issues: Array<string>;
    labeling?: string;
    legalBasis?: LegalBasis;
    lineage?: string;
    method?: string;
    methods: Array<string>;
    mitigations?: string;
    name: string;
    origin?: string;
    overallRating?: DataQuality;
    purpose: DataPurpose;
    source?: string;
    thirdPartyProvider?: string;
    timeliness?: QualityRating;
    transformations: Array<string>;
}

export const Dataset = {
    $type: 'Dataset',
    accuracy: 'accuracy',
    aiSystemRefs: 'aiSystemRefs',
    assessed: 'assessed',
    augmentation: 'augmentation',
    completeness: 'completeness',
    consentObtained: 'consentObtained',
    consistency: 'consistency',
    description: 'description',
    findings: 'findings',
    issues: 'issues',
    labeling: 'labeling',
    legalBasis: 'legalBasis',
    lineage: 'lineage',
    method: 'method',
    methods: 'methods',
    mitigations: 'mitigations',
    name: 'name',
    origin: 'origin',
    overallRating: 'overallRating',
    purpose: 'purpose',
    source: 'source',
    thirdPartyProvider: 'thirdPartyProvider',
    timeliness: 'timeliness',
    transformations: 'transformations'
} as const;

export function isDataset(item: unknown): item is Dataset {
    return reflection.isInstance(item, Dataset.$type);
}

export type DecisionStatus = 'CANCELLED' | 'COMPLETED' | 'DEFERRED' | 'IN_PROGRESS' | 'PENDING';

export function isDecisionStatus(item: unknown): item is DecisionStatus {
    return item === 'PENDING' || item === 'IN_PROGRESS' || item === 'COMPLETED' || item === 'DEFERRED' || item === 'CANCELLED';
}

export type DecisionType = 'IMPROVEMENT' | 'OBJECTIVE_UPDATE' | 'OTHER' | 'POLICY_CHANGE' | 'RESOURCE_ALLOCATION' | 'RISK_TREATMENT';

export function isDecisionType(item: unknown): item is DecisionType {
    return item === 'IMPROVEMENT' || item === 'RESOURCE_ALLOCATION' || item === 'POLICY_CHANGE' || item === 'OBJECTIVE_UPDATE' || item === 'RISK_TREATMENT' || item === 'OTHER';
}

export interface Document extends langium.AstNode {
    readonly $container: DocumentRegistry;
    readonly $type: 'Document';
    classification?: DataSensitivity;
    controlRefs: Array<langium.Reference<Control>>;
    createdDate?: string;
    lastReviewDate?: string;
    location?: string;
    name: string;
    nextReviewDate?: string;
    owner?: string;
    retentionPeriod?: string;
    status?: DocumentStatus;
    title: string;
    type: DocumentType;
    version?: string;
}

export const Document = {
    $type: 'Document',
    classification: 'classification',
    controlRefs: 'controlRefs',
    createdDate: 'createdDate',
    lastReviewDate: 'lastReviewDate',
    location: 'location',
    name: 'name',
    nextReviewDate: 'nextReviewDate',
    owner: 'owner',
    retentionPeriod: 'retentionPeriod',
    status: 'status',
    title: 'title',
    type: 'type',
    version: 'version'
} as const;

export function isDocument(item: unknown): item is Document {
    return reflection.isInstance(item, Document.$type);
}

export interface DocumentRegistry extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'DocumentRegistry';
    description?: string;
    documents: Array<Document>;
    name: string;
}

export const DocumentRegistry = {
    $type: 'DocumentRegistry',
    description: 'description',
    documents: 'documents',
    name: 'name'
} as const;

export function isDocumentRegistry(item: unknown): item is DocumentRegistry {
    return reflection.isInstance(item, DocumentRegistry.$type);
}

export type DocumentStatus = 'APPROVED' | 'ARCHIVED' | 'DRAFT' | 'IN_REVIEW' | 'OBSOLETE' | 'PUBLISHED' | 'UNDER_REVISION';

export function isDocumentStatus(item: unknown): item is DocumentStatus {
    return item === 'DRAFT' || item === 'IN_REVIEW' || item === 'APPROVED' || item === 'PUBLISHED' || item === 'UNDER_REVISION' || item === 'OBSOLETE' || item === 'ARCHIVED';
}

export type DocumentType = 'ASSESSMENT' | 'CONTRACT' | 'FORM' | 'GUIDELINE' | 'LOG' | 'OTHER' | 'PLAN' | 'POLICY' | 'PROCEDURE' | 'RECORD' | 'REPORT' | 'SPECIFICATION' | 'STANDARD' | 'TEMPLATE' | 'TRAINING_MATERIAL';

export function isDocumentType(item: unknown): item is DocumentType {
    return item === 'POLICY' || item === 'PROCEDURE' || item === 'GUIDELINE' || item === 'STANDARD' || item === 'PLAN' || item === 'RECORD' || item === 'REPORT' || item === 'FORM' || item === 'TEMPLATE' || item === 'TRAINING_MATERIAL' || item === 'SPECIFICATION' || item === 'CONTRACT' || item === 'ASSESSMENT' || item === 'LOG' || item === 'OTHER';
}

export interface EnvironmentalImpact extends langium.AstNode {
    readonly $container: ImpactAssessment;
    readonly $type: 'EnvironmentalImpact';
    description: string;
    name: string;
    severity?: ImpactSeverity;
    type?: EnvironmentalImpactType;
}

export const EnvironmentalImpact = {
    $type: 'EnvironmentalImpact',
    description: 'description',
    name: 'name',
    severity: 'severity',
    type: 'type'
} as const;

export function isEnvironmentalImpact(item: unknown): item is EnvironmentalImpact {
    return reflection.isInstance(item, EnvironmentalImpact.$type);
}

export type EnvironmentalImpactType = 'CARBON_EMISSIONS' | 'ENERGY_CONSUMPTION' | 'E_WASTE' | 'OTHER' | 'RESOURCE_DEPLETION' | 'WATER_USAGE';

export function isEnvironmentalImpactType(item: unknown): item is EnvironmentalImpactType {
    return item === 'ENERGY_CONSUMPTION' || item === 'CARBON_EMISSIONS' || item === 'E_WASTE' || item === 'RESOURCE_DEPLETION' || item === 'WATER_USAGE' || item === 'OTHER';
}

export type EUAIActCategory = 'GPAI' | 'HIGH_RISK' | 'LIMITED_RISK' | 'MINIMAL_RISK' | 'NOT_APPLICABLE' | 'PROHIBITED';

export function isEUAIActCategory(item: unknown): item is EUAIActCategory {
    return item === 'PROHIBITED' || item === 'HIGH_RISK' || item === 'LIMITED_RISK' || item === 'MINIMAL_RISK' || item === 'GPAI' || item === 'NOT_APPLICABLE';
}

export interface Evidence extends langium.AstNode {
    readonly $container: Control;
    readonly $type: 'Evidence';
    collectedBy?: string;
    collectedDate?: string;
    description: string;
    location?: string;
    name: string;
    type: EvidenceType;
    validity?: EvidenceValidity;
}

export const Evidence = {
    $type: 'Evidence',
    collectedBy: 'collectedBy',
    collectedDate: 'collectedDate',
    description: 'description',
    location: 'location',
    name: 'name',
    type: 'type',
    validity: 'validity'
} as const;

export function isEvidence(item: unknown): item is Evidence {
    return reflection.isInstance(item, Evidence.$type);
}

export type EvidenceType = 'CERTIFICATE' | 'CONFIGURATION' | 'CONTRACT' | 'INTERVIEW' | 'LOG' | 'OBSERVATION' | 'OTHER' | 'POLICY' | 'PROCEDURE' | 'RECORD' | 'REPORT' | 'SCREENSHOT' | 'STANDARD' | 'TEST_RESULT';

export function isEvidenceType(item: unknown): item is EvidenceType {
    return item === 'POLICY' || item === 'PROCEDURE' || item === 'RECORD' || item === 'LOG' || item === 'SCREENSHOT' || item === 'CONFIGURATION' || item === 'INTERVIEW' || item === 'OBSERVATION' || item === 'TEST_RESULT' || item === 'REPORT' || item === 'CERTIFICATE' || item === 'CONTRACT' || item === 'STANDARD' || item === 'OTHER';
}

export type EvidenceValidity = 'CURRENT' | 'EXPIRED' | 'PENDING_REVIEW' | 'SUPERSEDED';

export function isEvidenceValidity(item: unknown): item is EvidenceValidity {
    return item === 'CURRENT' || item === 'EXPIRED' || item === 'PENDING_REVIEW' || item === 'SUPERSEDED';
}

export type FindingType = 'MAJOR_NC' | 'MINOR_NC' | 'OBSERVATION' | 'OPPORTUNITY' | 'STRENGTH';

export function isFindingType(item: unknown): item is FindingType {
    return item === 'MAJOR_NC' || item === 'MINOR_NC' || item === 'OBSERVATION' || item === 'OPPORTUNITY' || item === 'STRENGTH';
}

export interface ImpactAssessment extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'ImpactAssessment';
    aiSystem: langium.Reference<AISystem>;
    approver?: string;
    assessmentDate: string;
    assessor?: string;
    benefits: Array<Benefit>;
    conclusionNextReview?: string;
    conditions: Array<string>;
    decision?: AssessmentDecision;
    environmentalImpacts: Array<EnvironmentalImpact>;
    foreseeableMisuse?: string;
    individualImpacts: Array<IndividualImpact>;
    intendedUse?: string;
    methodology?: string;
    mitigations: Array<ImpactMitigation>;
    name: string;
    nextReviewDate?: string;
    operationalContext?: string;
    overallRiskLevel?: RiskLevel;
    recommendation?: string;
    reviewer?: string;
    societalImpacts: Array<SocietalImpact>;
    status?: AssessmentStatus;
    summary?: string;
    version?: string;
}

export const ImpactAssessment = {
    $type: 'ImpactAssessment',
    aiSystem: 'aiSystem',
    approver: 'approver',
    assessmentDate: 'assessmentDate',
    assessor: 'assessor',
    benefits: 'benefits',
    conclusionNextReview: 'conclusionNextReview',
    conditions: 'conditions',
    decision: 'decision',
    environmentalImpacts: 'environmentalImpacts',
    foreseeableMisuse: 'foreseeableMisuse',
    individualImpacts: 'individualImpacts',
    intendedUse: 'intendedUse',
    methodology: 'methodology',
    mitigations: 'mitigations',
    name: 'name',
    nextReviewDate: 'nextReviewDate',
    operationalContext: 'operationalContext',
    overallRiskLevel: 'overallRiskLevel',
    recommendation: 'recommendation',
    reviewer: 'reviewer',
    societalImpacts: 'societalImpacts',
    status: 'status',
    summary: 'summary',
    version: 'version'
} as const;

export function isImpactAssessment(item: unknown): item is ImpactAssessment {
    return reflection.isInstance(item, ImpactAssessment.$type);
}

export type ImpactLevel = 'CATASTROPHIC' | 'MAJOR' | 'MINOR' | 'MODERATE' | 'NEGLIGIBLE';

export function isImpactLevel(item: unknown): item is ImpactLevel {
    return item === 'NEGLIGIBLE' || item === 'MINOR' || item === 'MODERATE' || item === 'MAJOR' || item === 'CATASTROPHIC';
}

export interface ImpactMitigation extends langium.AstNode {
    readonly $container: ImpactAssessment;
    readonly $type: 'ImpactMitigation';
    effectiveness?: MitigationEffectiveness;
    impact: string;
    measure: string;
    name: string;
    owner?: string;
    status?: MitigationStatus;
}

export const ImpactMitigation = {
    $type: 'ImpactMitigation',
    effectiveness: 'effectiveness',
    impact: 'impact',
    measure: 'measure',
    name: 'name',
    owner: 'owner',
    status: 'status'
} as const;

export function isImpactMitigation(item: unknown): item is ImpactMitigation {
    return reflection.isInstance(item, ImpactMitigation.$type);
}

export type ImpactScale = 'GLOBAL' | 'LOCAL' | 'NATIONAL' | 'REGIONAL';

export function isImpactScale(item: unknown): item is ImpactScale {
    return item === 'LOCAL' || item === 'REGIONAL' || item === 'NATIONAL' || item === 'GLOBAL';
}

export type ImpactSeverity = 'MINOR' | 'MODERATE' | 'NEGLIGIBLE' | 'SEVERE' | 'SIGNIFICANT';

export function isImpactSeverity(item: unknown): item is ImpactSeverity {
    return item === 'NEGLIGIBLE' || item === 'MINOR' || item === 'MODERATE' || item === 'SIGNIFICANT' || item === 'SEVERE';
}

export type ImplementationStatus = 'FULLY_IMPLEMENTED' | 'NOT_APPLICABLE' | 'NOT_ASSESSED' | 'NOT_IMPLEMENTED' | 'PARTIALLY_IMPLEMENTED';

export function isImplementationStatus(item: unknown): item is ImplementationStatus {
    return item === 'NOT_APPLICABLE' || item === 'NOT_IMPLEMENTED' || item === 'PARTIALLY_IMPLEMENTED' || item === 'FULLY_IMPLEMENTED' || item === 'NOT_ASSESSED';
}

export interface Import extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'Import';
    importedNamespace: QualifiedNameWithWildcard;
}

export const Import = {
    $type: 'Import',
    importedNamespace: 'importedNamespace'
} as const;

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import.$type);
}

export interface ImprovementInitiative extends langium.AstNode {
    readonly $container: ImprovementPlan;
    readonly $type: 'ImprovementInitiative';
    actualBenefits?: string;
    description: string;
    expectedBenefits?: string;
    name: string;
    objectiveRefs: Array<langium.Reference<AIObjective>>;
    owner?: string;
    priority?: PriorityLevel;
    resources?: string;
    startDate?: string;
    status?: InitiativeStatus;
    targetDate?: string;
    title: string;
    type?: InitiativeType;
}

export const ImprovementInitiative = {
    $type: 'ImprovementInitiative',
    actualBenefits: 'actualBenefits',
    description: 'description',
    expectedBenefits: 'expectedBenefits',
    name: 'name',
    objectiveRefs: 'objectiveRefs',
    owner: 'owner',
    priority: 'priority',
    resources: 'resources',
    startDate: 'startDate',
    status: 'status',
    targetDate: 'targetDate',
    title: 'title',
    type: 'type'
} as const;

export function isImprovementInitiative(item: unknown): item is ImprovementInitiative {
    return reflection.isInstance(item, ImprovementInitiative.$type);
}

export interface ImprovementPlan extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'ImprovementPlan';
    description?: string;
    endDate?: string;
    initiatives: Array<ImprovementInitiative>;
    name: string;
    nonconformities: Array<Nonconformity>;
    startDate?: string;
}

export const ImprovementPlan = {
    $type: 'ImprovementPlan',
    description: 'description',
    endDate: 'endDate',
    initiatives: 'initiatives',
    name: 'name',
    nonconformities: 'nonconformities',
    startDate: 'startDate'
} as const;

export function isImprovementPlan(item: unknown): item is ImprovementPlan {
    return reflection.isInstance(item, ImprovementPlan.$type);
}

export interface IncidentRegistry extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'IncidentRegistry';
    description?: string;
    incidents: Array<AIIncident>;
    name: string;
}

export const IncidentRegistry = {
    $type: 'IncidentRegistry',
    description: 'description',
    incidents: 'incidents',
    name: 'name'
} as const;

export function isIncidentRegistry(item: unknown): item is IncidentRegistry {
    return reflection.isInstance(item, IncidentRegistry.$type);
}

export type IncidentRootCause = 'CONFIGURATION_ERROR' | 'DATA_ISSUE' | 'EXTERNAL_ATTACK' | 'HUMAN_ERROR' | 'INFRASTRUCTURE' | 'INTEGRATION_FAILURE' | 'MODEL_ISSUE' | 'THIRD_PARTY' | 'UNKNOWN';

export function isIncidentRootCause(item: unknown): item is IncidentRootCause {
    return item === 'DATA_ISSUE' || item === 'MODEL_ISSUE' || item === 'CONFIGURATION_ERROR' || item === 'INTEGRATION_FAILURE' || item === 'HUMAN_ERROR' || item === 'EXTERNAL_ATTACK' || item === 'INFRASTRUCTURE' || item === 'THIRD_PARTY' || item === 'UNKNOWN';
}

export type IncidentSeverity = 'CRITICAL' | 'HIGH' | 'LOW' | 'MEDIUM';

export function isIncidentSeverity(item: unknown): item is IncidentSeverity {
    return item === 'LOW' || item === 'MEDIUM' || item === 'HIGH' || item === 'CRITICAL';
}

export type IncidentStatus = 'CLOSED' | 'CONTAINED' | 'DETECTED' | 'INVESTIGATING' | 'POST_MORTEM' | 'RESOLVED' | 'TRIAGED';

export function isIncidentStatus(item: unknown): item is IncidentStatus {
    return item === 'DETECTED' || item === 'TRIAGED' || item === 'INVESTIGATING' || item === 'CONTAINED' || item === 'RESOLVED' || item === 'CLOSED' || item === 'POST_MORTEM';
}

export type IncidentType = 'AVAILABILITY' | 'BIAS_DETECTION' | 'COMPLIANCE_VIOLATION' | 'DATA_BREACH' | 'MISUSE' | 'MODEL_FAILURE' | 'OTHER' | 'PERFORMANCE_DEGRADATION' | 'SAFETY_ISSUE' | 'SECURITY_BREACH' | 'UNINTENDED_BEHAVIOR';

export function isIncidentType(item: unknown): item is IncidentType {
    return item === 'BIAS_DETECTION' || item === 'MODEL_FAILURE' || item === 'DATA_BREACH' || item === 'SAFETY_ISSUE' || item === 'SECURITY_BREACH' || item === 'AVAILABILITY' || item === 'MISUSE' || item === 'UNINTENDED_BEHAVIOR' || item === 'PERFORMANCE_DEGRADATION' || item === 'COMPLIANCE_VIOLATION' || item === 'OTHER';
}

export type IndicatorStatus = 'CRITICAL' | 'NORMAL' | 'WARNING';

export function isIndicatorStatus(item: unknown): item is IndicatorStatus {
    return item === 'NORMAL' || item === 'WARNING' || item === 'CRITICAL';
}

export interface IndividualImpact extends langium.AstNode {
    readonly $container: ImpactAssessment;
    readonly $type: 'IndividualImpact';
    affectedGroups: Array<string>;
    description: string;
    likelihood?: LikelihoodLevel;
    name: string;
    reversibility?: Reversibility;
    severity?: ImpactSeverity;
    type?: IndividualImpactType;
}

export const IndividualImpact = {
    $type: 'IndividualImpact',
    affectedGroups: 'affectedGroups',
    description: 'description',
    likelihood: 'likelihood',
    name: 'name',
    reversibility: 'reversibility',
    severity: 'severity',
    type: 'type'
} as const;

export function isIndividualImpact(item: unknown): item is IndividualImpact {
    return reflection.isInstance(item, IndividualImpact.$type);
}

export type IndividualImpactType = 'ACCESS' | 'AUTONOMY' | 'CIVIL_RIGHTS' | 'DIGNITY' | 'DISCRIMINATION' | 'EMPLOYMENT' | 'FINANCIAL' | 'OTHER' | 'PRIVACY' | 'PSYCHOLOGICAL' | 'SAFETY';

export function isIndividualImpactType(item: unknown): item is IndividualImpactType {
    return item === 'PRIVACY' || item === 'AUTONOMY' || item === 'SAFETY' || item === 'DIGNITY' || item === 'DISCRIMINATION' || item === 'ACCESS' || item === 'FINANCIAL' || item === 'PSYCHOLOGICAL' || item === 'EMPLOYMENT' || item === 'CIVIL_RIGHTS' || item === 'OTHER';
}

export type IndustrySector = 'EDUCATION' | 'ENERGY' | 'FINANCE' | 'GOVERNMENT' | 'HEALTHCARE' | 'MANUFACTURING' | 'MEDIA' | 'OTHER' | 'PROFESSIONAL_SERVICES' | 'RETAIL' | 'TECHNOLOGY' | 'TELECOMMUNICATIONS' | 'TRANSPORTATION';

export function isIndustrySector(item: unknown): item is IndustrySector {
    return item === 'HEALTHCARE' || item === 'FINANCE' || item === 'MANUFACTURING' || item === 'RETAIL' || item === 'TECHNOLOGY' || item === 'GOVERNMENT' || item === 'EDUCATION' || item === 'TRANSPORTATION' || item === 'ENERGY' || item === 'TELECOMMUNICATIONS' || item === 'MEDIA' || item === 'PROFESSIONAL_SERVICES' || item === 'OTHER';
}

export type InfluenceLevel = 'HIGH' | 'LOW' | 'MEDIUM' | 'VERY_HIGH';

export function isInfluenceLevel(item: unknown): item is InfluenceLevel {
    return item === 'LOW' || item === 'MEDIUM' || item === 'HIGH' || item === 'VERY_HIGH';
}

export type InitiativeStatus = 'APPROVED' | 'CANCELLED' | 'COMPLETED' | 'IN_PROGRESS' | 'ON_HOLD' | 'PROPOSED';

export function isInitiativeStatus(item: unknown): item is InitiativeStatus {
    return item === 'PROPOSED' || item === 'APPROVED' || item === 'IN_PROGRESS' || item === 'ON_HOLD' || item === 'COMPLETED' || item === 'CANCELLED';
}

export type InitiativeType = 'AUTOMATION' | 'CAPABILITY_BUILDING' | 'COMPLIANCE' | 'INTEGRATION' | 'OTHER' | 'PERFORMANCE' | 'PROCESS_IMPROVEMENT' | 'TECHNOLOGY_UPGRADE';

export function isInitiativeType(item: unknown): item is InitiativeType {
    return item === 'PROCESS_IMPROVEMENT' || item === 'TECHNOLOGY_UPGRADE' || item === 'CAPABILITY_BUILDING' || item === 'AUTOMATION' || item === 'INTEGRATION' || item === 'COMPLIANCE' || item === 'PERFORMANCE' || item === 'OTHER';
}

export type IntegrationStatus = 'CERTIFIED' | 'INTEGRATED' | 'IN_PROGRESS' | 'NOT_STARTED' | 'PLANNED';

export function isIntegrationStatus(item: unknown): item is IntegrationStatus {
    return item === 'NOT_STARTED' || item === 'PLANNED' || item === 'IN_PROGRESS' || item === 'INTEGRATED' || item === 'CERTIFIED';
}

export type InterestLevel = 'HIGH' | 'LOW' | 'MEDIUM' | 'VERY_HIGH';

export function isInterestLevel(item: unknown): item is InterestLevel {
    return item === 'LOW' || item === 'MEDIUM' || item === 'HIGH' || item === 'VERY_HIGH';
}

export type IssueStatus = 'CLOSED' | 'ESCALATED' | 'IN_PROGRESS' | 'OPEN' | 'RESOLVED';

export function isIssueStatus(item: unknown): item is IssueStatus {
    return item === 'OPEN' || item === 'IN_PROGRESS' || item === 'RESOLVED' || item === 'ESCALATED' || item === 'CLOSED';
}

export type LegalBasis = 'CONSENT' | 'CONTRACT' | 'LEGAL_OBLIGATION' | 'LEGITIMATE_INTERESTS' | 'NOT_APPLICABLE' | 'PUBLIC_TASK' | 'VITAL_INTERESTS';

export function isLegalBasis(item: unknown): item is LegalBasis {
    return item === 'CONSENT' || item === 'CONTRACT' || item === 'LEGAL_OBLIGATION' || item === 'VITAL_INTERESTS' || item === 'PUBLIC_TASK' || item === 'LEGITIMATE_INTERESTS' || item === 'NOT_APPLICABLE';
}

export type LifecycleStage = 'DEPLOYMENT' | 'DESIGN' | 'DEVELOPMENT' | 'MONITORING' | 'OPERATION' | 'RETIREMENT' | 'VALIDATION' | 'VERIFICATION';

export function isLifecycleStage(item: unknown): item is LifecycleStage {
    return item === 'DESIGN' || item === 'DEVELOPMENT' || item === 'VERIFICATION' || item === 'VALIDATION' || item === 'DEPLOYMENT' || item === 'OPERATION' || item === 'MONITORING' || item === 'RETIREMENT';
}

export type LikelihoodLevel = 'ALMOST_CERTAIN' | 'LIKELY' | 'POSSIBLE' | 'RARE' | 'UNLIKELY';

export function isLikelihoodLevel(item: unknown): item is LikelihoodLevel {
    return item === 'RARE' || item === 'UNLIKELY' || item === 'POSSIBLE' || item === 'LIKELY' || item === 'ALMOST_CERTAIN';
}

export interface Location extends langium.AstNode {
    readonly $container: Organization;
    readonly $type: 'Location';
    country?: string;
    name: string;
    region?: string;
}

export const Location = {
    $type: 'Location',
    country: 'country',
    name: 'name',
    region: 'region'
} as const;

export function isLocation(item: unknown): item is Location {
    return reflection.isInstance(item, Location.$type);
}

export interface ManagementDecision extends langium.AstNode {
    readonly $container: ManagementReview;
    readonly $type: 'ManagementDecision';
    action?: string;
    description: string;
    dueDate?: string;
    name: string;
    owner?: string;
    status?: DecisionStatus;
    type?: DecisionType;
}

export const ManagementDecision = {
    $type: 'ManagementDecision',
    action: 'action',
    description: 'description',
    dueDate: 'dueDate',
    name: 'name',
    owner: 'owner',
    status: 'status',
    type: 'type'
} as const;

export function isManagementDecision(item: unknown): item is ManagementDecision {
    return reflection.isInstance(item, ManagementDecision.$type);
}

export interface ManagementReview extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'ManagementReview';
    aimsPerformance?: string;
    auditResults?: string;
    chairperson?: string;
    changesAffectingAIMS?: string;
    date: string;
    decisions: Array<ManagementDecision>;
    monitoringResults?: string;
    name: string;
    nextReviewDate?: string;
    nonconformities?: string;
    opportunitiesForImprovement?: string;
    participants: Array<string>;
    previousActionsStatus?: string;
    resourceAdequacy?: string;
    riskAssessmentResults?: string;
    stakeholderFeedback?: string;
}

export const ManagementReview = {
    $type: 'ManagementReview',
    aimsPerformance: 'aimsPerformance',
    auditResults: 'auditResults',
    chairperson: 'chairperson',
    changesAffectingAIMS: 'changesAffectingAIMS',
    date: 'date',
    decisions: 'decisions',
    monitoringResults: 'monitoringResults',
    name: 'name',
    nextReviewDate: 'nextReviewDate',
    nonconformities: 'nonconformities',
    opportunitiesForImprovement: 'opportunitiesForImprovement',
    participants: 'participants',
    previousActionsStatus: 'previousActionsStatus',
    resourceAdequacy: 'resourceAdequacy',
    riskAssessmentResults: 'riskAssessmentResults',
    stakeholderFeedback: 'stakeholderFeedback'
} as const;

export function isManagementReview(item: unknown): item is ManagementReview {
    return reflection.isInstance(item, ManagementReview.$type);
}

export type ManagementStandard = 'EU_AI_ACT' | 'ISO_14001' | 'ISO_22301' | 'ISO_27001' | 'ISO_27701' | 'ISO_31000' | 'ISO_9001' | 'NIST_AI_RMF' | 'OTHER' | 'SOC2';

export function isManagementStandard(item: unknown): item is ManagementStandard {
    return item === 'ISO_27001' || item === 'ISO_27701' || item === 'ISO_9001' || item === 'ISO_14001' || item === 'ISO_22301' || item === 'ISO_31000' || item === 'SOC2' || item === 'NIST_AI_RMF' || item === 'EU_AI_ACT' || item === 'OTHER';
}

export interface ManagementSystemIntegration extends langium.AstNode {
    readonly $container: Organization;
    readonly $type: 'ManagementSystemIntegration';
    gapAnalysis?: string;
    sharedElements: Array<string>;
    standard: ManagementStandard;
    status?: IntegrationStatus;
}

export const ManagementSystemIntegration = {
    $type: 'ManagementSystemIntegration',
    gapAnalysis: 'gapAnalysis',
    sharedElements: 'sharedElements',
    standard: 'standard',
    status: 'status'
} as const;

export function isManagementSystemIntegration(item: unknown): item is ManagementSystemIntegration {
    return reflection.isInstance(item, ManagementSystemIntegration.$type);
}

export type MaturityLevel = 'DEFINED' | 'INITIAL' | 'MANAGED' | 'OPTIMIZING' | 'QUANTITATIVELY_MANAGED';

export function isMaturityLevel(item: unknown): item is MaturityLevel {
    return item === 'INITIAL' || item === 'MANAGED' || item === 'DEFINED' || item === 'QUANTITATIVELY_MANAGED' || item === 'OPTIMIZING';
}

export type MitigationEffectiveness = 'HIGH' | 'LOW' | 'MEDIUM' | 'UNVERIFIED';

export function isMitigationEffectiveness(item: unknown): item is MitigationEffectiveness {
    return item === 'UNVERIFIED' || item === 'LOW' || item === 'MEDIUM' || item === 'HIGH';
}

export type MitigationStatus = 'APPROVED' | 'IMPLEMENTED' | 'PROPOSED' | 'VERIFIED';

export function isMitigationStatus(item: unknown): item is MitigationStatus {
    return item === 'PROPOSED' || item === 'APPROVED' || item === 'IMPLEMENTED' || item === 'VERIFIED';
}

export type MLApproach = 'FEDERATED' | 'OTHER' | 'REINFORCEMENT' | 'SEMI_SUPERVISED' | 'SUPERVISED' | 'TRANSFER_LEARNING' | 'UNSUPERVISED';

export function isMLApproach(item: unknown): item is MLApproach {
    return item === 'SUPERVISED' || item === 'UNSUPERVISED' || item === 'SEMI_SUPERVISED' || item === 'REINFORCEMENT' || item === 'TRANSFER_LEARNING' || item === 'FEDERATED' || item === 'OTHER';
}

export type ModelElement = AIManagementSystem | AISystem | AuditProgram | ControlCatalog | DataInventory | DocumentRegistry | ImpactAssessment | ImprovementPlan | IncidentRegistry | ManagementReview | Organization | RiskRegistry | StakeholderRegistry | StatementOfApplicability | SupplierRegistry;

export const ModelElement = {
    $type: 'ModelElement'
} as const;

export function isModelElement(item: unknown): item is ModelElement {
    return reflection.isInstance(item, ModelElement.$type);
}

export interface Nonconformity extends langium.AstNode {
    readonly $container: ImprovementPlan;
    readonly $type: 'Nonconformity';
    clause?: string;
    completedDate?: string;
    correctiveDesc?: string;
    description: string;
    detectedDate?: string;
    dueDate?: string;
    immediateCompletedDate?: string;
    immediateDesc?: string;
    name: string;
    owner?: string;
    preventiveAction?: string;
    rootCauseAnalysis?: string;
    source?: NonconformitySource;
    status?: CorrectiveActionStatus;
    verificationDate?: string;
    verificationEvidence?: string;
    verificationMethod?: string;
    verificationResult?: VerificationResult;
}

export const Nonconformity = {
    $type: 'Nonconformity',
    clause: 'clause',
    completedDate: 'completedDate',
    correctiveDesc: 'correctiveDesc',
    description: 'description',
    detectedDate: 'detectedDate',
    dueDate: 'dueDate',
    immediateCompletedDate: 'immediateCompletedDate',
    immediateDesc: 'immediateDesc',
    name: 'name',
    owner: 'owner',
    preventiveAction: 'preventiveAction',
    rootCauseAnalysis: 'rootCauseAnalysis',
    source: 'source',
    status: 'status',
    verificationDate: 'verificationDate',
    verificationEvidence: 'verificationEvidence',
    verificationMethod: 'verificationMethod',
    verificationResult: 'verificationResult'
} as const;

export function isNonconformity(item: unknown): item is Nonconformity {
    return reflection.isInstance(item, Nonconformity.$type);
}

export type NonconformitySource = 'COMPLAINT' | 'CUSTOMER' | 'EXTERNAL_AUDIT' | 'INCIDENT' | 'INTERNAL_AUDIT' | 'MANAGEMENT_REVIEW' | 'OTHER' | 'REGULATORY' | 'SELF_ASSESSMENT';

export function isNonconformitySource(item: unknown): item is NonconformitySource {
    return item === 'INTERNAL_AUDIT' || item === 'EXTERNAL_AUDIT' || item === 'INCIDENT' || item === 'COMPLAINT' || item === 'MANAGEMENT_REVIEW' || item === 'SELF_ASSESSMENT' || item === 'REGULATORY' || item === 'CUSTOMER' || item === 'OTHER';
}

export type ObjectiveStatus = 'ACHIEVED' | 'DEFERRED' | 'IN_PROGRESS' | 'NOT_ACHIEVED' | 'NOT_STARTED';

export function isObjectiveStatus(item: unknown): item is ObjectiveStatus {
    return item === 'NOT_STARTED' || item === 'IN_PROGRESS' || item === 'ACHIEVED' || item === 'NOT_ACHIEVED' || item === 'DEFERRED';
}

export interface Organization extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'Organization';
    aiRoles: Array<AIRole>;
    description?: string;
    externalIssues: Array<ContextIssue>;
    industry?: IndustrySector;
    internalIssues: Array<ContextIssue>;
    locations: Array<Location>;
    managementSystems: Array<ManagementSystemIntegration>;
    name: string;
    size?: OrganizationSize;
    stakeholders: Array<StakeholderReference>;
}

export const Organization = {
    $type: 'Organization',
    aiRoles: 'aiRoles',
    description: 'description',
    externalIssues: 'externalIssues',
    industry: 'industry',
    internalIssues: 'internalIssues',
    locations: 'locations',
    managementSystems: 'managementSystems',
    name: 'name',
    size: 'size',
    stakeholders: 'stakeholders'
} as const;

export function isOrganization(item: unknown): item is Organization {
    return reflection.isInstance(item, Organization.$type);
}

export type OrganizationSize = 'ENTERPRISE' | 'LARGE' | 'MEDIUM' | 'SMALL' | 'STARTUP';

export function isOrganizationSize(item: unknown): item is OrganizationSize {
    return item === 'STARTUP' || item === 'SMALL' || item === 'MEDIUM' || item === 'LARGE' || item === 'ENTERPRISE';
}

export type PrincipleCategory = 'ACCOUNTABILITY' | 'EXPLAINABILITY' | 'FAIRNESS' | 'HUMAN_OVERSIGHT' | 'PRIVACY' | 'RELIABILITY' | 'ROBUSTNESS' | 'SAFETY' | 'SECURITY' | 'SUSTAINABILITY' | 'TRANSPARENCY';

export function isPrincipleCategory(item: unknown): item is PrincipleCategory {
    return item === 'ACCOUNTABILITY' || item === 'TRANSPARENCY' || item === 'EXPLAINABILITY' || item === 'FAIRNESS' || item === 'PRIVACY' || item === 'SAFETY' || item === 'SECURITY' || item === 'ROBUSTNESS' || item === 'HUMAN_OVERSIGHT' || item === 'SUSTAINABILITY' || item === 'RELIABILITY';
}

export type PriorityLevel = 'CRITICAL' | 'HIGH' | 'LOW' | 'MEDIUM';

export function isPriorityLevel(item: unknown): item is PriorityLevel {
    return item === 'LOW' || item === 'MEDIUM' || item === 'HIGH' || item === 'CRITICAL';
}

export type QualifiedName = string;

export function isQualifiedName(item: unknown): item is QualifiedName {
    return typeof item === 'string';
}

export type QualifiedNameWithWildcard = string;

export function isQualifiedNameWithWildcard(item: unknown): item is QualifiedNameWithWildcard {
    return typeof item === 'string';
}

export type QualityRating = 'EXCELLENT' | 'FAIR' | 'GOOD' | 'NOT_ASSESSED' | 'POOR';

export function isQualityRating(item: unknown): item is QualityRating {
    return item === 'POOR' || item === 'FAIR' || item === 'GOOD' || item === 'EXCELLENT' || item === 'NOT_ASSESSED';
}

export type RelevanceLevel = 'CRITICAL' | 'HIGH' | 'LOW' | 'MEDIUM';

export function isRelevanceLevel(item: unknown): item is RelevanceLevel {
    return item === 'LOW' || item === 'MEDIUM' || item === 'HIGH' || item === 'CRITICAL';
}

export type Reversibility = 'IRREVERSIBLE' | 'PARTIALLY_REVERSIBLE' | 'REVERSIBLE';

export function isReversibility(item: unknown): item is Reversibility {
    return item === 'REVERSIBLE' || item === 'PARTIALLY_REVERSIBLE' || item === 'IRREVERSIBLE';
}

export interface Risk extends langium.AstNode {
    readonly $container: RiskRegistry;
    readonly $type: 'Risk';
    affectedSystems: Array<langium.Reference<AISystem>>;
    category?: AIRiskCategory;
    controlRefs: Array<langium.Reference<Control>>;
    description: string;
    dueDate?: string;
    frequency?: string;
    impact?: ImpactLevel;
    indicators: Array<RiskIndicator>;
    inherentRisk?: RiskRating;
    likelihood?: LikelihoodLevel;
    name: string;
    owner?: string;
    residualRisk?: RiskRating;
    source?: AIRiskSource;
    status?: TreatmentStatus;
    strategy?: TreatmentStrategy;
    treatmentDesc?: string;
    trend?: RiskTrend;
}

export const Risk = {
    $type: 'Risk',
    affectedSystems: 'affectedSystems',
    category: 'category',
    controlRefs: 'controlRefs',
    description: 'description',
    dueDate: 'dueDate',
    frequency: 'frequency',
    impact: 'impact',
    indicators: 'indicators',
    inherentRisk: 'inherentRisk',
    likelihood: 'likelihood',
    name: 'name',
    owner: 'owner',
    residualRisk: 'residualRisk',
    source: 'source',
    status: 'status',
    strategy: 'strategy',
    treatmentDesc: 'treatmentDesc',
    trend: 'trend'
} as const;

export function isRisk(item: unknown): item is Risk {
    return reflection.isInstance(item, Risk.$type);
}

export interface RiskCategoryDef extends langium.AstNode {
    readonly $container: RiskRegistry;
    readonly $type: 'RiskCategoryDef';
    description: string;
    name: string;
}

export const RiskCategoryDef = {
    $type: 'RiskCategoryDef',
    description: 'description',
    name: 'name'
} as const;

export function isRiskCategoryDef(item: unknown): item is RiskCategoryDef {
    return reflection.isInstance(item, RiskCategoryDef.$type);
}

export interface RiskIndicator extends langium.AstNode {
    readonly $container: Risk;
    readonly $type: 'RiskIndicator';
    currentValue?: string;
    description: string;
    name: string;
    status?: IndicatorStatus;
    threshold?: string;
}

export const RiskIndicator = {
    $type: 'RiskIndicator',
    currentValue: 'currentValue',
    description: 'description',
    name: 'name',
    status: 'status',
    threshold: 'threshold'
} as const;

export function isRiskIndicator(item: unknown): item is RiskIndicator {
    return reflection.isInstance(item, RiskIndicator.$type);
}

export type RiskLevel = 'HIGH' | 'LIMITED' | 'MINIMAL' | 'UNACCEPTABLE';

export function isRiskLevel(item: unknown): item is RiskLevel {
    return item === 'MINIMAL' || item === 'LIMITED' || item === 'HIGH' || item === 'UNACCEPTABLE';
}

export type RiskRating = 'CRITICAL' | 'HIGH' | 'LOW' | 'MEDIUM' | 'VERY_HIGH' | 'VERY_LOW';

export function isRiskRating(item: unknown): item is RiskRating {
    return item === 'VERY_LOW' || item === 'LOW' || item === 'MEDIUM' || item === 'HIGH' || item === 'VERY_HIGH' || item === 'CRITICAL';
}

export interface RiskRegistry extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'RiskRegistry';
    categories: Array<RiskCategoryDef>;
    description?: string;
    lastReviewDate?: string;
    methodology?: string;
    name: string;
    nextReviewDate?: string;
    risks: Array<Risk>;
}

export const RiskRegistry = {
    $type: 'RiskRegistry',
    categories: 'categories',
    description: 'description',
    lastReviewDate: 'lastReviewDate',
    methodology: 'methodology',
    name: 'name',
    nextReviewDate: 'nextReviewDate',
    risks: 'risks'
} as const;

export function isRiskRegistry(item: unknown): item is RiskRegistry {
    return reflection.isInstance(item, RiskRegistry.$type);
}

export type RiskTrend = 'DECREASING' | 'INCREASING' | 'STABLE';

export function isRiskTrend(item: unknown): item is RiskTrend {
    return item === 'DECREASING' || item === 'STABLE' || item === 'INCREASING';
}

export interface ScopeBoundary extends langium.AstNode {
    readonly $container: AIManagementSystem;
    readonly $type: 'ScopeBoundary';
    description: string;
    name: string;
    type: BoundaryType;
}

export const ScopeBoundary = {
    $type: 'ScopeBoundary',
    description: 'description',
    name: 'name',
    type: 'type'
} as const;

export function isScopeBoundary(item: unknown): item is ScopeBoundary {
    return reflection.isInstance(item, ScopeBoundary.$type);
}

export interface ScopeExclusion extends langium.AstNode {
    readonly $container: AIManagementSystem;
    readonly $type: 'ScopeExclusion';
    description: string;
    justification: string;
    name: string;
}

export const ScopeExclusion = {
    $type: 'ScopeExclusion',
    description: 'description',
    justification: 'justification',
    name: 'name'
} as const;

export function isScopeExclusion(item: unknown): item is ScopeExclusion {
    return reflection.isInstance(item, ScopeExclusion.$type);
}

export interface SocietalImpact extends langium.AstNode {
    readonly $container: ImpactAssessment;
    readonly $type: 'SocietalImpact';
    description: string;
    name: string;
    scale?: ImpactScale;
    severity?: ImpactSeverity;
    type?: SocietalImpactType;
}

export const SocietalImpact = {
    $type: 'SocietalImpact',
    description: 'description',
    name: 'name',
    scale: 'scale',
    severity: 'severity',
    type: 'type'
} as const;

export function isSocietalImpact(item: unknown): item is SocietalImpact {
    return reflection.isInstance(item, SocietalImpact.$type);
}

export type SocietalImpactType = 'CRITICAL_INFRASTRUCTURE' | 'CULTURAL' | 'DEMOCRATIC_PROCESSES' | 'ECONOMIC_INEQUALITY' | 'EDUCATION' | 'ENVIRONMENT' | 'HEALTHCARE' | 'LABOR_MARKET' | 'OTHER' | 'PUBLIC_SAFETY' | 'SOCIAL_COHESION';

export function isSocietalImpactType(item: unknown): item is SocietalImpactType {
    return item === 'DEMOCRATIC_PROCESSES' || item === 'SOCIAL_COHESION' || item === 'ECONOMIC_INEQUALITY' || item === 'LABOR_MARKET' || item === 'PUBLIC_SAFETY' || item === 'CRITICAL_INFRASTRUCTURE' || item === 'EDUCATION' || item === 'HEALTHCARE' || item === 'ENVIRONMENT' || item === 'CULTURAL' || item === 'OTHER';
}

export interface Stakeholder extends langium.AstNode {
    readonly $container: StakeholderRegistry;
    readonly $type: 'Stakeholder';
    description?: string;
    expectations: Array<StakeholderExpectation>;
    frequency?: string;
    influence?: InfluenceLevel;
    interest?: InterestLevel;
    method?: string;
    name: string;
    needs: Array<StakeholderNeed>;
    responsible?: string;
    type: StakeholderType;
}

export const Stakeholder = {
    $type: 'Stakeholder',
    description: 'description',
    expectations: 'expectations',
    frequency: 'frequency',
    influence: 'influence',
    interest: 'interest',
    method: 'method',
    name: 'name',
    needs: 'needs',
    responsible: 'responsible',
    type: 'type'
} as const;

export function isStakeholder(item: unknown): item is Stakeholder {
    return reflection.isInstance(item, Stakeholder.$type);
}

export interface StakeholderExpectation extends langium.AstNode {
    readonly $container: Stakeholder;
    readonly $type: 'StakeholderExpectation';
    description: string;
    met: boolean;
    name: string;
}

export const StakeholderExpectation = {
    $type: 'StakeholderExpectation',
    description: 'description',
    met: 'met',
    name: 'name'
} as const;

export function isStakeholderExpectation(item: unknown): item is StakeholderExpectation {
    return reflection.isInstance(item, StakeholderExpectation.$type);
}

export interface StakeholderNeed extends langium.AstNode {
    readonly $container: Stakeholder;
    readonly $type: 'StakeholderNeed';
    addressed: boolean;
    description: string;
    name: string;
}

export const StakeholderNeed = {
    $type: 'StakeholderNeed',
    addressed: 'addressed',
    description: 'description',
    name: 'name'
} as const;

export function isStakeholderNeed(item: unknown): item is StakeholderNeed {
    return reflection.isInstance(item, StakeholderNeed.$type);
}

export interface StakeholderReference extends langium.AstNode {
    readonly $container: Organization;
    readonly $type: 'StakeholderReference';
    stakeholder: langium.Reference<Stakeholder>;
}

export const StakeholderReference = {
    $type: 'StakeholderReference',
    stakeholder: 'stakeholder'
} as const;

export function isStakeholderReference(item: unknown): item is StakeholderReference {
    return reflection.isInstance(item, StakeholderReference.$type);
}

export interface StakeholderRegistry extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'StakeholderRegistry';
    description?: string;
    name: string;
    stakeholders: Array<Stakeholder>;
}

export const StakeholderRegistry = {
    $type: 'StakeholderRegistry',
    description: 'description',
    name: 'name',
    stakeholders: 'stakeholders'
} as const;

export function isStakeholderRegistry(item: unknown): item is StakeholderRegistry {
    return reflection.isInstance(item, StakeholderRegistry.$type);
}

export type StakeholderType = 'ADVOCACY_GROUP' | 'AFFECTED_INDIVIDUAL' | 'AI_SYSTEM_OPERATOR' | 'COMMUNITY' | 'CUSTOMER' | 'DATA_SUBJECT' | 'EMPLOYEE' | 'MEDIA' | 'OTHER' | 'PARTNER' | 'REGULATOR' | 'SHAREHOLDER' | 'SUPPLIER' | 'USER';

export function isStakeholderType(item: unknown): item is StakeholderType {
    return item === 'CUSTOMER' || item === 'USER' || item === 'REGULATOR' || item === 'SHAREHOLDER' || item === 'EMPLOYEE' || item === 'SUPPLIER' || item === 'PARTNER' || item === 'COMMUNITY' || item === 'MEDIA' || item === 'ADVOCACY_GROUP' || item === 'AFFECTED_INDIVIDUAL' || item === 'DATA_SUBJECT' || item === 'AI_SYSTEM_OPERATOR' || item === 'OTHER';
}

export interface StatementOfApplicability extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'StatementOfApplicability';
    aimsRef?: langium.Reference<AIManagementSystem>;
    approvedBy?: string;
    controlDeclarations: Array<ControlDeclaration>;
    date?: string;
    name: string;
    version?: string;
}

export const StatementOfApplicability = {
    $type: 'StatementOfApplicability',
    aimsRef: 'aimsRef',
    approvedBy: 'approvedBy',
    controlDeclarations: 'controlDeclarations',
    date: 'date',
    name: 'name',
    version: 'version'
} as const;

export function isStatementOfApplicability(item: unknown): item is StatementOfApplicability {
    return reflection.isInstance(item, StatementOfApplicability.$type);
}

export interface Supplier extends langium.AstNode {
    readonly $container: SupplierRegistry;
    readonly $type: 'Supplier';
    aiPoliciesReviewed: boolean;
    aiRequirements?: string;
    auditRights: boolean;
    certifications: Array<string>;
    companyName: string;
    complianceVerified: boolean;
    criticality?: CriticalityLevel;
    dataProtectionClause: boolean;
    endDate?: string;
    ethicsReviewed: boolean;
    incidentNotification: boolean;
    issues: Array<SupplierIssue>;
    lastReviewDate?: string;
    name: string;
    nextReviewDate?: string;
    performanceRating?: QualityRating;
    riskLevel?: RiskRating;
    securityAssessed: boolean;
    services: Array<string>;
    startDate?: string;
    type?: SupplierType;
}

export const Supplier = {
    $type: 'Supplier',
    aiPoliciesReviewed: 'aiPoliciesReviewed',
    aiRequirements: 'aiRequirements',
    auditRights: 'auditRights',
    certifications: 'certifications',
    companyName: 'companyName',
    complianceVerified: 'complianceVerified',
    criticality: 'criticality',
    dataProtectionClause: 'dataProtectionClause',
    endDate: 'endDate',
    ethicsReviewed: 'ethicsReviewed',
    incidentNotification: 'incidentNotification',
    issues: 'issues',
    lastReviewDate: 'lastReviewDate',
    name: 'name',
    nextReviewDate: 'nextReviewDate',
    performanceRating: 'performanceRating',
    riskLevel: 'riskLevel',
    securityAssessed: 'securityAssessed',
    services: 'services',
    startDate: 'startDate',
    type: 'type'
} as const;

export function isSupplier(item: unknown): item is Supplier {
    return reflection.isInstance(item, Supplier.$type);
}

export interface SupplierIssue extends langium.AstNode {
    readonly $container: Supplier;
    readonly $type: 'SupplierIssue';
    description: string;
    name: string;
    reportedDate?: string;
    resolvedDate?: string;
    status?: IssueStatus;
}

export const SupplierIssue = {
    $type: 'SupplierIssue',
    description: 'description',
    name: 'name',
    reportedDate: 'reportedDate',
    resolvedDate: 'resolvedDate',
    status: 'status'
} as const;

export function isSupplierIssue(item: unknown): item is SupplierIssue {
    return reflection.isInstance(item, SupplierIssue.$type);
}

export interface SupplierRegistry extends langium.AstNode {
    readonly $container: AssessmentModel;
    readonly $type: 'SupplierRegistry';
    description?: string;
    name: string;
    suppliers: Array<Supplier>;
}

export const SupplierRegistry = {
    $type: 'SupplierRegistry',
    description: 'description',
    name: 'name',
    suppliers: 'suppliers'
} as const;

export function isSupplierRegistry(item: unknown): item is SupplierRegistry {
    return reflection.isInstance(item, SupplierRegistry.$type);
}

export type SupplierType = 'AI_MODEL_PROVIDER' | 'CERTIFICATION' | 'CLOUD_PROVIDER' | 'CONSULTING' | 'DATA_PROVIDER' | 'HARDWARE_PROVIDER' | 'OTHER' | 'SOFTWARE_PROVIDER' | 'TRAINING';

export function isSupplierType(item: unknown): item is SupplierType {
    return item === 'AI_MODEL_PROVIDER' || item === 'DATA_PROVIDER' || item === 'CLOUD_PROVIDER' || item === 'HARDWARE_PROVIDER' || item === 'SOFTWARE_PROVIDER' || item === 'CONSULTING' || item === 'TRAINING' || item === 'CERTIFICATION' || item === 'OTHER';
}

export type SystemStatus = 'CONCEPT' | 'DEPRECATED' | 'DEVELOPMENT' | 'MAINTENANCE' | 'PILOT' | 'PRODUCTION' | 'RETIRED' | 'TESTING';

export function isSystemStatus(item: unknown): item is SystemStatus {
    return item === 'CONCEPT' || item === 'DEVELOPMENT' || item === 'TESTING' || item === 'PILOT' || item === 'PRODUCTION' || item === 'MAINTENANCE' || item === 'DEPRECATED' || item === 'RETIRED';
}

export interface TeamMember extends langium.AstNode {
    readonly $container: AISystem;
    readonly $type: 'TeamMember';
    competencies: Array<string>;
    name: string;
    responsibilities?: string;
    role: string;
}

export const TeamMember = {
    $type: 'TeamMember',
    competencies: 'competencies',
    name: 'name',
    responsibilities: 'responsibilities',
    role: 'role'
} as const;

export function isTeamMember(item: unknown): item is TeamMember {
    return reflection.isInstance(item, TeamMember.$type);
}

export interface Tool extends langium.AstNode {
    readonly $container: AISystem;
    readonly $type: 'Tool';
    name: string;
    provider?: string;
    purpose: string;
    version?: string;
}

export const Tool = {
    $type: 'Tool',
    name: 'name',
    provider: 'provider',
    purpose: 'purpose',
    version: 'version'
} as const;

export function isTool(item: unknown): item is Tool {
    return reflection.isInstance(item, Tool.$type);
}

export type TreatmentStatus = 'CLOSED' | 'IMPLEMENTED' | 'IN_PROGRESS' | 'PLANNED' | 'VERIFIED';

export function isTreatmentStatus(item: unknown): item is TreatmentStatus {
    return item === 'PLANNED' || item === 'IN_PROGRESS' || item === 'IMPLEMENTED' || item === 'VERIFIED' || item === 'CLOSED';
}

export type TreatmentStrategy = 'ACCEPT' | 'AVOID' | 'MITIGATE' | 'TRANSFER';

export function isTreatmentStrategy(item: unknown): item is TreatmentStrategy {
    return item === 'AVOID' || item === 'MITIGATE' || item === 'TRANSFER' || item === 'ACCEPT';
}

export type VerificationResult = 'FAILED' | 'INCONCLUSIVE' | 'NOT_TESTED' | 'PARTIALLY_PASSED' | 'PASSED';

export function isVerificationResult(item: unknown): item is VerificationResult {
    return item === 'NOT_TESTED' || item === 'PASSED' || item === 'FAILED' || item === 'PARTIALLY_PASSED' || item === 'INCONCLUSIVE';
}

export type Iso42001AstType = {
    AIComponent: AIComponent
    AIIncident: AIIncident
    AIManagementSystem: AIManagementSystem
    AIObjective: AIObjective
    AIPrinciple: AIPrinciple
    AIRole: AIRole
    AISystem: AISystem
    AssessmentModel: AssessmentModel
    Audit: Audit
    AuditFinding: AuditFinding
    AuditProgram: AuditProgram
    Benefit: Benefit
    Competency: Competency
    ContextIssue: ContextIssue
    Control: Control
    ControlCatalog: ControlCatalog
    ControlDeclaration: ControlDeclaration
    ControlFamily: ControlFamily
    ControlMapping: ControlMapping
    DataInventory: DataInventory
    DataResource: DataResource
    Dataset: Dataset
    Document: Document
    DocumentRegistry: DocumentRegistry
    EnvironmentalImpact: EnvironmentalImpact
    Evidence: Evidence
    ImpactAssessment: ImpactAssessment
    ImpactMitigation: ImpactMitigation
    Import: Import
    ImprovementInitiative: ImprovementInitiative
    ImprovementPlan: ImprovementPlan
    IncidentRegistry: IncidentRegistry
    IndividualImpact: IndividualImpact
    Location: Location
    ManagementDecision: ManagementDecision
    ManagementReview: ManagementReview
    ManagementSystemIntegration: ManagementSystemIntegration
    ModelElement: ModelElement
    Nonconformity: Nonconformity
    Organization: Organization
    Risk: Risk
    RiskCategoryDef: RiskCategoryDef
    RiskIndicator: RiskIndicator
    RiskRegistry: RiskRegistry
    ScopeBoundary: ScopeBoundary
    ScopeExclusion: ScopeExclusion
    SocietalImpact: SocietalImpact
    Stakeholder: Stakeholder
    StakeholderExpectation: StakeholderExpectation
    StakeholderNeed: StakeholderNeed
    StakeholderReference: StakeholderReference
    StakeholderRegistry: StakeholderRegistry
    StatementOfApplicability: StatementOfApplicability
    Supplier: Supplier
    SupplierIssue: SupplierIssue
    SupplierRegistry: SupplierRegistry
    TeamMember: TeamMember
    Tool: Tool
}

export class Iso42001AstReflection extends langium.AbstractAstReflection {
    override readonly types = {
        AIComponent: {
            name: AIComponent.$type,
            properties: {
                description: {
                    name: AIComponent.description
                },
                license: {
                    name: AIComponent.license
                },
                name: {
                    name: AIComponent.name
                },
                provider: {
                    name: AIComponent.provider
                },
                type: {
                    name: AIComponent.type
                },
                version: {
                    name: AIComponent.version
                }
            },
            superTypes: []
        },
        AIIncident: {
            name: AIIncident.$type,
            properties: {
                affectedSystem: {
                    name: AIIncident.affectedSystem,
                    referenceType: AISystem.$type
                },
                affectedUsers: {
                    name: AIIncident.affectedUsers
                },
                businessImpact: {
                    name: AIIncident.businessImpact
                },
                communicationRecord: {
                    name: AIIncident.communicationRecord
                },
                containment: {
                    name: AIIncident.containment
                },
                description: {
                    name: AIIncident.description
                },
                detectedDate: {
                    name: AIIncident.detectedDate
                },
                immediateActions: {
                    name: AIIncident.immediateActions
                },
                impactDesc: {
                    name: AIIncident.impactDesc
                },
                internalNotified: {
                    name: AIIncident.internalNotified,
                    defaultValue: false
                },
                lessonLearned: {
                    name: AIIncident.lessonLearned
                },
                name: {
                    name: AIIncident.name
                },
                regulatorsNotified: {
                    name: AIIncident.regulatorsNotified,
                    defaultValue: false
                },
                reportedBy: {
                    name: AIIncident.reportedBy
                },
                resolvedDate: {
                    name: AIIncident.resolvedDate
                },
                rootCause: {
                    name: AIIncident.rootCause
                },
                severity: {
                    name: AIIncident.severity
                },
                status: {
                    name: AIIncident.status
                },
                type: {
                    name: AIIncident.type
                },
                usersNotified: {
                    name: AIIncident.usersNotified,
                    defaultValue: false
                }
            },
            superTypes: []
        },
        AIManagementSystem: {
            name: AIManagementSystem.$type,
            properties: {
                aiSystemRefs: {
                    name: AIManagementSystem.aiSystemRefs,
                    defaultValue: [],
                    referenceType: AISystem.$type
                },
                approvalDate: {
                    name: AIManagementSystem.approvalDate
                },
                approvedBy: {
                    name: AIManagementSystem.approvedBy
                },
                boundaries: {
                    name: AIManagementSystem.boundaries,
                    defaultValue: []
                },
                commitments: {
                    name: AIManagementSystem.commitments,
                    defaultValue: []
                },
                documentRefs: {
                    name: AIManagementSystem.documentRefs,
                    defaultValue: [],
                    referenceType: Document.$type
                },
                effectiveDate: {
                    name: AIManagementSystem.effectiveDate
                },
                exclusions: {
                    name: AIManagementSystem.exclusions,
                    defaultValue: []
                },
                name: {
                    name: AIManagementSystem.name
                },
                objectives: {
                    name: AIManagementSystem.objectives,
                    defaultValue: []
                },
                organization: {
                    name: AIManagementSystem.organization,
                    referenceType: Organization.$type
                },
                policyStatement: {
                    name: AIManagementSystem.policyStatement
                },
                principles: {
                    name: AIManagementSystem.principles,
                    defaultValue: []
                },
                reviewDate: {
                    name: AIManagementSystem.reviewDate
                },
                scopeDescription: {
                    name: AIManagementSystem.scopeDescription
                },
                version: {
                    name: AIManagementSystem.version
                }
            },
            superTypes: [ModelElement.$type]
        },
        AIObjective: {
            name: AIObjective.$type,
            properties: {
                baseline: {
                    name: AIObjective.baseline
                },
                controlRefs: {
                    name: AIObjective.controlRefs,
                    defaultValue: [],
                    referenceType: Control.$type
                },
                deadline: {
                    name: AIObjective.deadline
                },
                description: {
                    name: AIObjective.description
                },
                metric: {
                    name: AIObjective.metric
                },
                name: {
                    name: AIObjective.name
                },
                owner: {
                    name: AIObjective.owner
                },
                status: {
                    name: AIObjective.status
                },
                target: {
                    name: AIObjective.target
                }
            },
            superTypes: []
        },
        AIPrinciple: {
            name: AIPrinciple.$type,
            properties: {
                category: {
                    name: AIPrinciple.category
                },
                description: {
                    name: AIPrinciple.description
                },
                implementation: {
                    name: AIPrinciple.implementation
                },
                name: {
                    name: AIPrinciple.name
                }
            },
            superTypes: []
        },
        AIRole: {
            name: AIRole.$type,
            properties: {
                assignedTo: {
                    name: AIRole.assignedTo
                },
                authority: {
                    name: AIRole.authority
                },
                competencies: {
                    name: AIRole.competencies,
                    defaultValue: []
                },
                name: {
                    name: AIRole.name
                },
                responsibilities: {
                    name: AIRole.responsibilities,
                    defaultValue: []
                },
                title: {
                    name: AIRole.title
                }
            },
            superTypes: []
        },
        AISystem: {
            name: AISystem.$type,
            properties: {
                affectedParties: {
                    name: AISystem.affectedParties,
                    defaultValue: []
                },
                autonomyLevel: {
                    name: AISystem.autonomyLevel
                },
                beneficiaries: {
                    name: AISystem.beneficiaries,
                    defaultValue: []
                },
                components: {
                    name: AISystem.components,
                    defaultValue: []
                },
                dataResources: {
                    name: AISystem.dataResources,
                    defaultValue: []
                },
                deploymentDate: {
                    name: AISystem.deploymentDate
                },
                description: {
                    name: AISystem.description
                },
                euAiActCategory: {
                    name: AISystem.euAiActCategory
                },
                foreseeableMisuse: {
                    name: AISystem.foreseeableMisuse
                },
                impactAssessmentRefs: {
                    name: AISystem.impactAssessmentRefs,
                    defaultValue: [],
                    referenceType: ImpactAssessment.$type
                },
                infrastructure: {
                    name: AISystem.infrastructure
                },
                intendedUse: {
                    name: AISystem.intendedUse
                },
                lifecycleStage: {
                    name: AISystem.lifecycleStage
                },
                mlApproach: {
                    name: AISystem.mlApproach
                },
                name: {
                    name: AISystem.name
                },
                requirements: {
                    name: AISystem.requirements
                },
                retirementDate: {
                    name: AISystem.retirementDate
                },
                riskLevel: {
                    name: AISystem.riskLevel
                },
                status: {
                    name: AISystem.status
                },
                suppliers: {
                    name: AISystem.suppliers,
                    defaultValue: [],
                    referenceType: Supplier.$type
                },
                teamMembers: {
                    name: AISystem.teamMembers,
                    defaultValue: []
                },
                tools: {
                    name: AISystem.tools,
                    defaultValue: []
                },
                type: {
                    name: AISystem.type
                },
                version: {
                    name: AISystem.version
                }
            },
            superTypes: [ModelElement.$type]
        },
        AssessmentModel: {
            name: AssessmentModel.$type,
            properties: {
                elements: {
                    name: AssessmentModel.elements,
                    defaultValue: []
                },
                imports: {
                    name: AssessmentModel.imports,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Audit: {
            name: Audit.$type,
            properties: {
                actualDate: {
                    name: Audit.actualDate
                },
                auditTeam: {
                    name: Audit.auditTeam,
                    defaultValue: []
                },
                conformityLevel: {
                    name: Audit.conformityLevel
                },
                criteria: {
                    name: Audit.criteria
                },
                findings: {
                    name: Audit.findings,
                    defaultValue: []
                },
                leadAuditor: {
                    name: Audit.leadAuditor
                },
                name: {
                    name: Audit.name
                },
                plannedDate: {
                    name: Audit.plannedDate
                },
                recommendations: {
                    name: Audit.recommendations,
                    defaultValue: []
                },
                scope: {
                    name: Audit.scope
                },
                status: {
                    name: Audit.status
                },
                summary: {
                    name: Audit.summary
                },
                type: {
                    name: Audit.type
                }
            },
            superTypes: []
        },
        AuditFinding: {
            name: AuditFinding.$type,
            properties: {
                actionDescription: {
                    name: AuditFinding.actionDescription
                },
                actionStatus: {
                    name: AuditFinding.actionStatus
                },
                clause: {
                    name: AuditFinding.clause
                },
                completedDate: {
                    name: AuditFinding.completedDate
                },
                control: {
                    name: AuditFinding.control,
                    referenceType: Control.$type
                },
                description: {
                    name: AuditFinding.description
                },
                dueDate: {
                    name: AuditFinding.dueDate
                },
                evidence: {
                    name: AuditFinding.evidence
                },
                name: {
                    name: AuditFinding.name
                },
                owner: {
                    name: AuditFinding.owner
                },
                rootCause: {
                    name: AuditFinding.rootCause
                },
                type: {
                    name: AuditFinding.type
                },
                verification: {
                    name: AuditFinding.verification
                }
            },
            superTypes: []
        },
        AuditProgram: {
            name: AuditProgram.$type,
            properties: {
                audits: {
                    name: AuditProgram.audits,
                    defaultValue: []
                },
                description: {
                    name: AuditProgram.description
                },
                name: {
                    name: AuditProgram.name
                },
                objectives: {
                    name: AuditProgram.objectives
                },
                year: {
                    name: AuditProgram.year
                }
            },
            superTypes: [ModelElement.$type]
        },
        Benefit: {
            name: Benefit.$type,
            properties: {
                beneficiaries: {
                    name: Benefit.beneficiaries,
                    defaultValue: []
                },
                description: {
                    name: Benefit.description
                },
                name: {
                    name: Benefit.name
                },
                significance: {
                    name: Benefit.significance
                }
            },
            superTypes: []
        },
        Competency: {
            name: Competency.$type,
            properties: {
                level: {
                    name: Competency.level
                },
                name: {
                    name: Competency.name
                }
            },
            superTypes: []
        },
        ContextIssue: {
            name: ContextIssue.$type,
            properties: {
                aiImplications: {
                    name: ContextIssue.aiImplications
                },
                category: {
                    name: ContextIssue.category
                },
                description: {
                    name: ContextIssue.description
                },
                name: {
                    name: ContextIssue.name
                },
                relevance: {
                    name: ContextIssue.relevance
                }
            },
            superTypes: []
        },
        Control: {
            name: Control.$type,
            properties: {
                completedDate: {
                    name: Control.completedDate
                },
                description: {
                    name: Control.description
                },
                dueDate: {
                    name: Control.dueDate
                },
                evidence: {
                    name: Control.evidence,
                    defaultValue: []
                },
                guidance: {
                    name: Control.guidance
                },
                implementationDesc: {
                    name: Control.implementationDesc
                },
                lastVerified: {
                    name: Control.lastVerified
                },
                mappings: {
                    name: Control.mappings,
                    defaultValue: []
                },
                maturity: {
                    name: Control.maturity
                },
                method: {
                    name: Control.method
                },
                mitigatedRisks: {
                    name: Control.mitigatedRisks,
                    defaultValue: [],
                    referenceType: Risk.$type
                },
                name: {
                    name: Control.name
                },
                objective: {
                    name: Control.objective
                },
                owner: {
                    name: Control.owner
                },
                status: {
                    name: Control.status
                },
                title: {
                    name: Control.title
                },
                verificationFrequency: {
                    name: Control.verificationFrequency
                },
                verificationMethod: {
                    name: Control.verificationMethod
                },
                verificationNotes: {
                    name: Control.verificationNotes
                },
                verificationResult: {
                    name: Control.verificationResult
                }
            },
            superTypes: []
        },
        ControlCatalog: {
            name: ControlCatalog.$type,
            properties: {
                basedOn: {
                    name: ControlCatalog.basedOn
                },
                controlFamilies: {
                    name: ControlCatalog.controlFamilies,
                    defaultValue: []
                },
                description: {
                    name: ControlCatalog.description
                },
                name: {
                    name: ControlCatalog.name
                },
                version: {
                    name: ControlCatalog.version
                }
            },
            superTypes: [ModelElement.$type]
        },
        ControlDeclaration: {
            name: ControlDeclaration.$type,
            properties: {
                applicable: {
                    name: ControlDeclaration.applicable,
                    defaultValue: false
                },
                control: {
                    name: ControlDeclaration.control,
                    referenceType: Control.$type
                },
                implementationNotes: {
                    name: ControlDeclaration.implementationNotes
                },
                justification: {
                    name: ControlDeclaration.justification
                }
            },
            superTypes: []
        },
        ControlFamily: {
            name: ControlFamily.$type,
            properties: {
                controls: {
                    name: ControlFamily.controls,
                    defaultValue: []
                },
                description: {
                    name: ControlFamily.description
                },
                name: {
                    name: ControlFamily.name
                },
                title: {
                    name: ControlFamily.title
                }
            },
            superTypes: []
        },
        ControlMapping: {
            name: ControlMapping.$type,
            properties: {
                framework: {
                    name: ControlMapping.framework
                },
                reference: {
                    name: ControlMapping.reference
                }
            },
            superTypes: []
        },
        DataInventory: {
            name: DataInventory.$type,
            properties: {
                datasets: {
                    name: DataInventory.datasets,
                    defaultValue: []
                },
                description: {
                    name: DataInventory.description
                },
                name: {
                    name: DataInventory.name
                }
            },
            superTypes: [ModelElement.$type]
        },
        DataResource: {
            name: DataResource.$type,
            properties: {
                biasAssessment: {
                    name: DataResource.biasAssessment
                },
                category: {
                    name: DataResource.category
                },
                description: {
                    name: DataResource.description
                },
                name: {
                    name: DataResource.name
                },
                provenance: {
                    name: DataResource.provenance
                },
                quality: {
                    name: DataResource.quality
                },
                retentionPeriod: {
                    name: DataResource.retentionPeriod
                },
                sensitivity: {
                    name: DataResource.sensitivity
                },
                source: {
                    name: DataResource.source
                },
                updateFrequency: {
                    name: DataResource.updateFrequency
                },
                volume: {
                    name: DataResource.volume
                }
            },
            superTypes: []
        },
        Dataset: {
            name: Dataset.$type,
            properties: {
                accuracy: {
                    name: Dataset.accuracy
                },
                aiSystemRefs: {
                    name: Dataset.aiSystemRefs,
                    defaultValue: [],
                    referenceType: AISystem.$type
                },
                assessed: {
                    name: Dataset.assessed,
                    defaultValue: false
                },
                augmentation: {
                    name: Dataset.augmentation
                },
                completeness: {
                    name: Dataset.completeness
                },
                consentObtained: {
                    name: Dataset.consentObtained,
                    defaultValue: false
                },
                consistency: {
                    name: Dataset.consistency
                },
                description: {
                    name: Dataset.description
                },
                findings: {
                    name: Dataset.findings
                },
                issues: {
                    name: Dataset.issues,
                    defaultValue: []
                },
                labeling: {
                    name: Dataset.labeling
                },
                legalBasis: {
                    name: Dataset.legalBasis
                },
                lineage: {
                    name: Dataset.lineage
                },
                method: {
                    name: Dataset.method
                },
                methods: {
                    name: Dataset.methods,
                    defaultValue: []
                },
                mitigations: {
                    name: Dataset.mitigations
                },
                name: {
                    name: Dataset.name
                },
                origin: {
                    name: Dataset.origin
                },
                overallRating: {
                    name: Dataset.overallRating
                },
                purpose: {
                    name: Dataset.purpose
                },
                source: {
                    name: Dataset.source
                },
                thirdPartyProvider: {
                    name: Dataset.thirdPartyProvider
                },
                timeliness: {
                    name: Dataset.timeliness
                },
                transformations: {
                    name: Dataset.transformations,
                    defaultValue: []
                }
            },
            superTypes: []
        },
        Document: {
            name: Document.$type,
            properties: {
                classification: {
                    name: Document.classification
                },
                controlRefs: {
                    name: Document.controlRefs,
                    defaultValue: [],
                    referenceType: Control.$type
                },
                createdDate: {
                    name: Document.createdDate
                },
                lastReviewDate: {
                    name: Document.lastReviewDate
                },
                location: {
                    name: Document.location
                },
                name: {
                    name: Document.name
                },
                nextReviewDate: {
                    name: Document.nextReviewDate
                },
                owner: {
                    name: Document.owner
                },
                retentionPeriod: {
                    name: Document.retentionPeriod
                },
                status: {
                    name: Document.status
                },
                title: {
                    name: Document.title
                },
                type: {
                    name: Document.type
                },
                version: {
                    name: Document.version
                }
            },
            superTypes: []
        },
        DocumentRegistry: {
            name: DocumentRegistry.$type,
            properties: {
                description: {
                    name: DocumentRegistry.description
                },
                documents: {
                    name: DocumentRegistry.documents,
                    defaultValue: []
                },
                name: {
                    name: DocumentRegistry.name
                }
            },
            superTypes: [ModelElement.$type]
        },
        EnvironmentalImpact: {
            name: EnvironmentalImpact.$type,
            properties: {
                description: {
                    name: EnvironmentalImpact.description
                },
                name: {
                    name: EnvironmentalImpact.name
                },
                severity: {
                    name: EnvironmentalImpact.severity
                },
                type: {
                    name: EnvironmentalImpact.type
                }
            },
            superTypes: []
        },
        Evidence: {
            name: Evidence.$type,
            properties: {
                collectedBy: {
                    name: Evidence.collectedBy
                },
                collectedDate: {
                    name: Evidence.collectedDate
                },
                description: {
                    name: Evidence.description
                },
                location: {
                    name: Evidence.location
                },
                name: {
                    name: Evidence.name
                },
                type: {
                    name: Evidence.type
                },
                validity: {
                    name: Evidence.validity
                }
            },
            superTypes: []
        },
        ImpactAssessment: {
            name: ImpactAssessment.$type,
            properties: {
                aiSystem: {
                    name: ImpactAssessment.aiSystem,
                    referenceType: AISystem.$type
                },
                approver: {
                    name: ImpactAssessment.approver
                },
                assessmentDate: {
                    name: ImpactAssessment.assessmentDate
                },
                assessor: {
                    name: ImpactAssessment.assessor
                },
                benefits: {
                    name: ImpactAssessment.benefits,
                    defaultValue: []
                },
                conclusionNextReview: {
                    name: ImpactAssessment.conclusionNextReview
                },
                conditions: {
                    name: ImpactAssessment.conditions,
                    defaultValue: []
                },
                decision: {
                    name: ImpactAssessment.decision
                },
                environmentalImpacts: {
                    name: ImpactAssessment.environmentalImpacts,
                    defaultValue: []
                },
                foreseeableMisuse: {
                    name: ImpactAssessment.foreseeableMisuse
                },
                individualImpacts: {
                    name: ImpactAssessment.individualImpacts,
                    defaultValue: []
                },
                intendedUse: {
                    name: ImpactAssessment.intendedUse
                },
                methodology: {
                    name: ImpactAssessment.methodology
                },
                mitigations: {
                    name: ImpactAssessment.mitigations,
                    defaultValue: []
                },
                name: {
                    name: ImpactAssessment.name
                },
                nextReviewDate: {
                    name: ImpactAssessment.nextReviewDate
                },
                operationalContext: {
                    name: ImpactAssessment.operationalContext
                },
                overallRiskLevel: {
                    name: ImpactAssessment.overallRiskLevel
                },
                recommendation: {
                    name: ImpactAssessment.recommendation
                },
                reviewer: {
                    name: ImpactAssessment.reviewer
                },
                societalImpacts: {
                    name: ImpactAssessment.societalImpacts,
                    defaultValue: []
                },
                status: {
                    name: ImpactAssessment.status
                },
                summary: {
                    name: ImpactAssessment.summary
                },
                version: {
                    name: ImpactAssessment.version
                }
            },
            superTypes: [ModelElement.$type]
        },
        ImpactMitigation: {
            name: ImpactMitigation.$type,
            properties: {
                effectiveness: {
                    name: ImpactMitigation.effectiveness
                },
                impact: {
                    name: ImpactMitigation.impact
                },
                measure: {
                    name: ImpactMitigation.measure
                },
                name: {
                    name: ImpactMitigation.name
                },
                owner: {
                    name: ImpactMitigation.owner
                },
                status: {
                    name: ImpactMitigation.status
                }
            },
            superTypes: []
        },
        Import: {
            name: Import.$type,
            properties: {
                importedNamespace: {
                    name: Import.importedNamespace
                }
            },
            superTypes: []
        },
        ImprovementInitiative: {
            name: ImprovementInitiative.$type,
            properties: {
                actualBenefits: {
                    name: ImprovementInitiative.actualBenefits
                },
                description: {
                    name: ImprovementInitiative.description
                },
                expectedBenefits: {
                    name: ImprovementInitiative.expectedBenefits
                },
                name: {
                    name: ImprovementInitiative.name
                },
                objectiveRefs: {
                    name: ImprovementInitiative.objectiveRefs,
                    defaultValue: [],
                    referenceType: AIObjective.$type
                },
                owner: {
                    name: ImprovementInitiative.owner
                },
                priority: {
                    name: ImprovementInitiative.priority
                },
                resources: {
                    name: ImprovementInitiative.resources
                },
                startDate: {
                    name: ImprovementInitiative.startDate
                },
                status: {
                    name: ImprovementInitiative.status
                },
                targetDate: {
                    name: ImprovementInitiative.targetDate
                },
                title: {
                    name: ImprovementInitiative.title
                },
                type: {
                    name: ImprovementInitiative.type
                }
            },
            superTypes: []
        },
        ImprovementPlan: {
            name: ImprovementPlan.$type,
            properties: {
                description: {
                    name: ImprovementPlan.description
                },
                endDate: {
                    name: ImprovementPlan.endDate
                },
                initiatives: {
                    name: ImprovementPlan.initiatives,
                    defaultValue: []
                },
                name: {
                    name: ImprovementPlan.name
                },
                nonconformities: {
                    name: ImprovementPlan.nonconformities,
                    defaultValue: []
                },
                startDate: {
                    name: ImprovementPlan.startDate
                }
            },
            superTypes: [ModelElement.$type]
        },
        IncidentRegistry: {
            name: IncidentRegistry.$type,
            properties: {
                description: {
                    name: IncidentRegistry.description
                },
                incidents: {
                    name: IncidentRegistry.incidents,
                    defaultValue: []
                },
                name: {
                    name: IncidentRegistry.name
                }
            },
            superTypes: [ModelElement.$type]
        },
        IndividualImpact: {
            name: IndividualImpact.$type,
            properties: {
                affectedGroups: {
                    name: IndividualImpact.affectedGroups,
                    defaultValue: []
                },
                description: {
                    name: IndividualImpact.description
                },
                likelihood: {
                    name: IndividualImpact.likelihood
                },
                name: {
                    name: IndividualImpact.name
                },
                reversibility: {
                    name: IndividualImpact.reversibility
                },
                severity: {
                    name: IndividualImpact.severity
                },
                type: {
                    name: IndividualImpact.type
                }
            },
            superTypes: []
        },
        Location: {
            name: Location.$type,
            properties: {
                country: {
                    name: Location.country
                },
                name: {
                    name: Location.name
                },
                region: {
                    name: Location.region
                }
            },
            superTypes: []
        },
        ManagementDecision: {
            name: ManagementDecision.$type,
            properties: {
                action: {
                    name: ManagementDecision.action
                },
                description: {
                    name: ManagementDecision.description
                },
                dueDate: {
                    name: ManagementDecision.dueDate
                },
                name: {
                    name: ManagementDecision.name
                },
                owner: {
                    name: ManagementDecision.owner
                },
                status: {
                    name: ManagementDecision.status
                },
                type: {
                    name: ManagementDecision.type
                }
            },
            superTypes: []
        },
        ManagementReview: {
            name: ManagementReview.$type,
            properties: {
                aimsPerformance: {
                    name: ManagementReview.aimsPerformance
                },
                auditResults: {
                    name: ManagementReview.auditResults
                },
                chairperson: {
                    name: ManagementReview.chairperson
                },
                changesAffectingAIMS: {
                    name: ManagementReview.changesAffectingAIMS
                },
                date: {
                    name: ManagementReview.date
                },
                decisions: {
                    name: ManagementReview.decisions,
                    defaultValue: []
                },
                monitoringResults: {
                    name: ManagementReview.monitoringResults
                },
                name: {
                    name: ManagementReview.name
                },
                nextReviewDate: {
                    name: ManagementReview.nextReviewDate
                },
                nonconformities: {
                    name: ManagementReview.nonconformities
                },
                opportunitiesForImprovement: {
                    name: ManagementReview.opportunitiesForImprovement
                },
                participants: {
                    name: ManagementReview.participants,
                    defaultValue: []
                },
                previousActionsStatus: {
                    name: ManagementReview.previousActionsStatus
                },
                resourceAdequacy: {
                    name: ManagementReview.resourceAdequacy
                },
                riskAssessmentResults: {
                    name: ManagementReview.riskAssessmentResults
                },
                stakeholderFeedback: {
                    name: ManagementReview.stakeholderFeedback
                }
            },
            superTypes: [ModelElement.$type]
        },
        ManagementSystemIntegration: {
            name: ManagementSystemIntegration.$type,
            properties: {
                gapAnalysis: {
                    name: ManagementSystemIntegration.gapAnalysis
                },
                sharedElements: {
                    name: ManagementSystemIntegration.sharedElements,
                    defaultValue: []
                },
                standard: {
                    name: ManagementSystemIntegration.standard
                },
                status: {
                    name: ManagementSystemIntegration.status
                }
            },
            superTypes: []
        },
        ModelElement: {
            name: ModelElement.$type,
            properties: {
            },
            superTypes: []
        },
        Nonconformity: {
            name: Nonconformity.$type,
            properties: {
                clause: {
                    name: Nonconformity.clause
                },
                completedDate: {
                    name: Nonconformity.completedDate
                },
                correctiveDesc: {
                    name: Nonconformity.correctiveDesc
                },
                description: {
                    name: Nonconformity.description
                },
                detectedDate: {
                    name: Nonconformity.detectedDate
                },
                dueDate: {
                    name: Nonconformity.dueDate
                },
                immediateCompletedDate: {
                    name: Nonconformity.immediateCompletedDate
                },
                immediateDesc: {
                    name: Nonconformity.immediateDesc
                },
                name: {
                    name: Nonconformity.name
                },
                owner: {
                    name: Nonconformity.owner
                },
                preventiveAction: {
                    name: Nonconformity.preventiveAction
                },
                rootCauseAnalysis: {
                    name: Nonconformity.rootCauseAnalysis
                },
                source: {
                    name: Nonconformity.source
                },
                status: {
                    name: Nonconformity.status
                },
                verificationDate: {
                    name: Nonconformity.verificationDate
                },
                verificationEvidence: {
                    name: Nonconformity.verificationEvidence
                },
                verificationMethod: {
                    name: Nonconformity.verificationMethod
                },
                verificationResult: {
                    name: Nonconformity.verificationResult
                }
            },
            superTypes: []
        },
        Organization: {
            name: Organization.$type,
            properties: {
                aiRoles: {
                    name: Organization.aiRoles,
                    defaultValue: []
                },
                description: {
                    name: Organization.description
                },
                externalIssues: {
                    name: Organization.externalIssues,
                    defaultValue: []
                },
                industry: {
                    name: Organization.industry
                },
                internalIssues: {
                    name: Organization.internalIssues,
                    defaultValue: []
                },
                locations: {
                    name: Organization.locations,
                    defaultValue: []
                },
                managementSystems: {
                    name: Organization.managementSystems,
                    defaultValue: []
                },
                name: {
                    name: Organization.name
                },
                size: {
                    name: Organization.size
                },
                stakeholders: {
                    name: Organization.stakeholders,
                    defaultValue: []
                }
            },
            superTypes: [ModelElement.$type]
        },
        Risk: {
            name: Risk.$type,
            properties: {
                affectedSystems: {
                    name: Risk.affectedSystems,
                    defaultValue: [],
                    referenceType: AISystem.$type
                },
                category: {
                    name: Risk.category
                },
                controlRefs: {
                    name: Risk.controlRefs,
                    defaultValue: [],
                    referenceType: Control.$type
                },
                description: {
                    name: Risk.description
                },
                dueDate: {
                    name: Risk.dueDate
                },
                frequency: {
                    name: Risk.frequency
                },
                impact: {
                    name: Risk.impact
                },
                indicators: {
                    name: Risk.indicators,
                    defaultValue: []
                },
                inherentRisk: {
                    name: Risk.inherentRisk
                },
                likelihood: {
                    name: Risk.likelihood
                },
                name: {
                    name: Risk.name
                },
                owner: {
                    name: Risk.owner
                },
                residualRisk: {
                    name: Risk.residualRisk
                },
                source: {
                    name: Risk.source
                },
                status: {
                    name: Risk.status
                },
                strategy: {
                    name: Risk.strategy
                },
                treatmentDesc: {
                    name: Risk.treatmentDesc
                },
                trend: {
                    name: Risk.trend
                }
            },
            superTypes: []
        },
        RiskCategoryDef: {
            name: RiskCategoryDef.$type,
            properties: {
                description: {
                    name: RiskCategoryDef.description
                },
                name: {
                    name: RiskCategoryDef.name
                }
            },
            superTypes: []
        },
        RiskIndicator: {
            name: RiskIndicator.$type,
            properties: {
                currentValue: {
                    name: RiskIndicator.currentValue
                },
                description: {
                    name: RiskIndicator.description
                },
                name: {
                    name: RiskIndicator.name
                },
                status: {
                    name: RiskIndicator.status
                },
                threshold: {
                    name: RiskIndicator.threshold
                }
            },
            superTypes: []
        },
        RiskRegistry: {
            name: RiskRegistry.$type,
            properties: {
                categories: {
                    name: RiskRegistry.categories,
                    defaultValue: []
                },
                description: {
                    name: RiskRegistry.description
                },
                lastReviewDate: {
                    name: RiskRegistry.lastReviewDate
                },
                methodology: {
                    name: RiskRegistry.methodology
                },
                name: {
                    name: RiskRegistry.name
                },
                nextReviewDate: {
                    name: RiskRegistry.nextReviewDate
                },
                risks: {
                    name: RiskRegistry.risks,
                    defaultValue: []
                }
            },
            superTypes: [ModelElement.$type]
        },
        ScopeBoundary: {
            name: ScopeBoundary.$type,
            properties: {
                description: {
                    name: ScopeBoundary.description
                },
                name: {
                    name: ScopeBoundary.name
                },
                type: {
                    name: ScopeBoundary.type
                }
            },
            superTypes: []
        },
        ScopeExclusion: {
            name: ScopeExclusion.$type,
            properties: {
                description: {
                    name: ScopeExclusion.description
                },
                justification: {
                    name: ScopeExclusion.justification
                },
                name: {
                    name: ScopeExclusion.name
                }
            },
            superTypes: []
        },
        SocietalImpact: {
            name: SocietalImpact.$type,
            properties: {
                description: {
                    name: SocietalImpact.description
                },
                name: {
                    name: SocietalImpact.name
                },
                scale: {
                    name: SocietalImpact.scale
                },
                severity: {
                    name: SocietalImpact.severity
                },
                type: {
                    name: SocietalImpact.type
                }
            },
            superTypes: []
        },
        Stakeholder: {
            name: Stakeholder.$type,
            properties: {
                description: {
                    name: Stakeholder.description
                },
                expectations: {
                    name: Stakeholder.expectations,
                    defaultValue: []
                },
                frequency: {
                    name: Stakeholder.frequency
                },
                influence: {
                    name: Stakeholder.influence
                },
                interest: {
                    name: Stakeholder.interest
                },
                method: {
                    name: Stakeholder.method
                },
                name: {
                    name: Stakeholder.name
                },
                needs: {
                    name: Stakeholder.needs,
                    defaultValue: []
                },
                responsible: {
                    name: Stakeholder.responsible
                },
                type: {
                    name: Stakeholder.type
                }
            },
            superTypes: []
        },
        StakeholderExpectation: {
            name: StakeholderExpectation.$type,
            properties: {
                description: {
                    name: StakeholderExpectation.description
                },
                met: {
                    name: StakeholderExpectation.met,
                    defaultValue: false
                },
                name: {
                    name: StakeholderExpectation.name
                }
            },
            superTypes: []
        },
        StakeholderNeed: {
            name: StakeholderNeed.$type,
            properties: {
                addressed: {
                    name: StakeholderNeed.addressed,
                    defaultValue: false
                },
                description: {
                    name: StakeholderNeed.description
                },
                name: {
                    name: StakeholderNeed.name
                }
            },
            superTypes: []
        },
        StakeholderReference: {
            name: StakeholderReference.$type,
            properties: {
                stakeholder: {
                    name: StakeholderReference.stakeholder,
                    referenceType: Stakeholder.$type
                }
            },
            superTypes: []
        },
        StakeholderRegistry: {
            name: StakeholderRegistry.$type,
            properties: {
                description: {
                    name: StakeholderRegistry.description
                },
                name: {
                    name: StakeholderRegistry.name
                },
                stakeholders: {
                    name: StakeholderRegistry.stakeholders,
                    defaultValue: []
                }
            },
            superTypes: [ModelElement.$type]
        },
        StatementOfApplicability: {
            name: StatementOfApplicability.$type,
            properties: {
                aimsRef: {
                    name: StatementOfApplicability.aimsRef,
                    referenceType: AIManagementSystem.$type
                },
                approvedBy: {
                    name: StatementOfApplicability.approvedBy
                },
                controlDeclarations: {
                    name: StatementOfApplicability.controlDeclarations,
                    defaultValue: []
                },
                date: {
                    name: StatementOfApplicability.date
                },
                name: {
                    name: StatementOfApplicability.name
                },
                version: {
                    name: StatementOfApplicability.version
                }
            },
            superTypes: [ModelElement.$type]
        },
        Supplier: {
            name: Supplier.$type,
            properties: {
                aiPoliciesReviewed: {
                    name: Supplier.aiPoliciesReviewed,
                    defaultValue: false
                },
                aiRequirements: {
                    name: Supplier.aiRequirements
                },
                auditRights: {
                    name: Supplier.auditRights,
                    defaultValue: false
                },
                certifications: {
                    name: Supplier.certifications,
                    defaultValue: []
                },
                companyName: {
                    name: Supplier.companyName
                },
                complianceVerified: {
                    name: Supplier.complianceVerified,
                    defaultValue: false
                },
                criticality: {
                    name: Supplier.criticality
                },
                dataProtectionClause: {
                    name: Supplier.dataProtectionClause,
                    defaultValue: false
                },
                endDate: {
                    name: Supplier.endDate
                },
                ethicsReviewed: {
                    name: Supplier.ethicsReviewed,
                    defaultValue: false
                },
                incidentNotification: {
                    name: Supplier.incidentNotification,
                    defaultValue: false
                },
                issues: {
                    name: Supplier.issues,
                    defaultValue: []
                },
                lastReviewDate: {
                    name: Supplier.lastReviewDate
                },
                name: {
                    name: Supplier.name
                },
                nextReviewDate: {
                    name: Supplier.nextReviewDate
                },
                performanceRating: {
                    name: Supplier.performanceRating
                },
                riskLevel: {
                    name: Supplier.riskLevel
                },
                securityAssessed: {
                    name: Supplier.securityAssessed,
                    defaultValue: false
                },
                services: {
                    name: Supplier.services,
                    defaultValue: []
                },
                startDate: {
                    name: Supplier.startDate
                },
                type: {
                    name: Supplier.type
                }
            },
            superTypes: []
        },
        SupplierIssue: {
            name: SupplierIssue.$type,
            properties: {
                description: {
                    name: SupplierIssue.description
                },
                name: {
                    name: SupplierIssue.name
                },
                reportedDate: {
                    name: SupplierIssue.reportedDate
                },
                resolvedDate: {
                    name: SupplierIssue.resolvedDate
                },
                status: {
                    name: SupplierIssue.status
                }
            },
            superTypes: []
        },
        SupplierRegistry: {
            name: SupplierRegistry.$type,
            properties: {
                description: {
                    name: SupplierRegistry.description
                },
                name: {
                    name: SupplierRegistry.name
                },
                suppliers: {
                    name: SupplierRegistry.suppliers,
                    defaultValue: []
                }
            },
            superTypes: [ModelElement.$type]
        },
        TeamMember: {
            name: TeamMember.$type,
            properties: {
                competencies: {
                    name: TeamMember.competencies,
                    defaultValue: []
                },
                name: {
                    name: TeamMember.name
                },
                responsibilities: {
                    name: TeamMember.responsibilities
                },
                role: {
                    name: TeamMember.role
                }
            },
            superTypes: []
        },
        Tool: {
            name: Tool.$type,
            properties: {
                name: {
                    name: Tool.name
                },
                provider: {
                    name: Tool.provider
                },
                purpose: {
                    name: Tool.purpose
                },
                version: {
                    name: Tool.version
                }
            },
            superTypes: []
        }
    } as const satisfies langium.AstMetaData
}

export const reflection = new Iso42001AstReflection();
